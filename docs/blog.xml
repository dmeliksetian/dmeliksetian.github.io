<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Dikran Meliksetian, Ph.D.</title>
<link>https://dikranmeliksetian.com/blog.html</link>
<atom:link href="https://dikranmeliksetian.com/blog.xml" rel="self" type="application/rss+xml"/>
<description>Personal academic portfolio and research blog exploring Quantum Computing, Qiskit, and Software Architecture.</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Fri, 05 Dec 2025 05:00:00 GMT</lastBuildDate>
<item>
  <title>Encoding Math into Metal: Representing Vectors and Matrices on a QPU</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal.html</link>
  <description><![CDATA[ 





<p>In my <a href="../../posts/quantum_diagonalization/02-variational-principle.html">previous post</a>, we established the mathematical goal of VQE: finding a normalized vector <img src="https://latex.codecogs.com/png.latex?v"> that minimizes the expectation value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>Mathematically, this is elegant. Computationally, it poses a massive storage problem. If our system has <img src="https://latex.codecogs.com/png.latex?N"> states, <img src="https://latex.codecogs.com/png.latex?v"> is a vector of size <img src="https://latex.codecogs.com/png.latex?N">, and <img src="https://latex.codecogs.com/png.latex?A"> is a matrix of size <img src="https://latex.codecogs.com/png.latex?N%20%5Ctimes%20N">. As we scale up, storing these explicitly becomes impossible.</p>
<p>To solve this on a quantum computer, we need to translate our classical data structures into quantum mechanics. We need to answer two fundamental questions:</p>
<ol type="1">
<li>How do we represent a high-dimensional vector <img src="https://latex.codecogs.com/png.latex?v"> on a quantum processor?</li>
<li>How do we represent the matrix <img src="https://latex.codecogs.com/png.latex?A"> so we can calculate its expectation value?</li>
</ol>
<section id="representing-an-n-dimensional-vector" class="level2">
<h2 class="anchored" data-anchor-id="representing-an-n-dimensional-vector">1. Representing an N-dimensional Vector</h2>
<p>In the classical world, if I want to store a state vector <img src="https://latex.codecogs.com/png.latex?v"> of size <img src="https://latex.codecogs.com/png.latex?N=4">, I allocate an array of 4 floating-point numbers in memory:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Av_%7Bclassical%7D%20=%20%5Cbegin%7Bbmatrix%7D%20v_0%20%5C%5C%20v_1%20%5C%5C%20v_2%20%5C%5C%20v_3%20%5Cend%7Bbmatrix%7D%0A"></p>
<p>The memory requirement grows linearly with <img src="https://latex.codecogs.com/png.latex?N">. However, in quantum problems, <img src="https://latex.codecogs.com/png.latex?N"> represents the dimension of the Hilbert space, which grows <strong>exponentially</strong> with the number of particles or qubits (<img src="https://latex.codecogs.com/png.latex?N%20=%202%5En">).</p>
<section id="the-quantum-compression" class="level3">
<h3 class="anchored" data-anchor-id="the-quantum-compression">The Quantum Compression</h3>
<p>On a quantum computer, we use <strong>Amplitude Encoding</strong>. We map the <strong>indices</strong> of the vector to the <strong>computational basis states</strong> of our qubits.</p>
<p>To represent a vector of size <img src="https://latex.codecogs.com/png.latex?N">, we need only <img src="https://latex.codecogs.com/png.latex?n%20=%20%5Clog_2(N)"> qubits. For our <img src="https://latex.codecogs.com/png.latex?N=4"> example, we need just <img src="https://latex.codecogs.com/png.latex?n=2"> qubits. The indices <img src="https://latex.codecogs.com/png.latex?0,%201,%202,%203"> correspond to the binary states <img src="https://latex.codecogs.com/png.latex?%7C00%5Crangle,%20%7C01%5Crangle,%20%7C10%5Crangle,%20%7C11%5Crangle">.</p>
<p>The vector <img src="https://latex.codecogs.com/png.latex?v"> is then represented as the <strong>superposition state</strong> of the quantum system:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7Cv%5Crangle%20=%20v_0%7C00%5Crangle%20+%20v_1%7C01%5Crangle%20+%20v_2%7C10%5Crangle%20+%20v_3%7C11%5Crangle%0A"></p>
</section>
<section id="the-constraint-normalization" class="level3">
<h3 class="anchored" data-anchor-id="the-constraint-normalization">The Constraint: Normalization</h3>
<p>There is one strict constraint. In classical coding, a vector can have any magnitude. In quantum mechanics, probabilities must sum to 1. Therefore, the vector <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> must be normalized such that the sum of the squared absolute values of its coefficients equals 1:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=0%7D%5E%7BN-1%7D%20%7Cv_i%7C%5E2%20=%201%0A"></p>
<p>This means that our quantum state <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> is mathematically identical to the normalized vector <img src="https://latex.codecogs.com/png.latex?v"> we discussed in the previous post. We aren’t “storing” the numbers <img src="https://latex.codecogs.com/png.latex?v_i"> in digital memory addresses; the numbers <img src="https://latex.codecogs.com/png.latex?v_i"> exist physically as the probability amplitudes of the wavefunction itself.</p>
</section>
</section>
<section id="representing-the-nxn-matrix" class="level2">
<h2 class="anchored" data-anchor-id="representing-the-nxn-matrix">2. Representing the NxN Matrix</h2>
<p>Now, what about the matrix <img src="https://latex.codecogs.com/png.latex?A">? Classically, <img src="https://latex.codecogs.com/png.latex?A"> is a dense grid of numbers. If the vector has dimension <img src="https://latex.codecogs.com/png.latex?N=2%5En">, the matrix has <img src="https://latex.codecogs.com/png.latex?(2%5En)%5E2"> entries. Storing a matrix for just 50 qubits would require more memory than exists on Earth.</p>
<p>In the quantum context, <img src="https://latex.codecogs.com/png.latex?A"> represents an observable (usually a Hamiltonian). We do not store this matrix in the quantum computer’s memory. Instead, we represent it in the native language of the quantum processor: <strong>Pauli Strings</strong>.</p>
<section id="the-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="the-decomposition">The Decomposition</h3>
<p>The set of Pauli matrices <img src="https://latex.codecogs.com/png.latex?%5C%7BI,%20X,%20Y,%20Z%5C%7D"> forms a complete basis for the space of <img src="https://latex.codecogs.com/png.latex?2%20%5Ctimes%202"> Hermitian matrices. For a multi-qubit system, we use tensor products of these matrices (e.g., <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z"> or <img src="https://latex.codecogs.com/png.latex?X%20%5Cotimes%20I">).</p>
<p>Any Hermitian matrix <img src="https://latex.codecogs.com/png.latex?A"> can be written as a weighted sum of these Pauli strings:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AA%20=%20%5Csum_%7Bj%7D%20c_j%20P_j%0A"></p>
<p>Where <img src="https://latex.codecogs.com/png.latex?c_j"> are real-valued scalar coefficients and <img src="https://latex.codecogs.com/png.latex?P_j"> are Pauli strings.</p>
</section>
<section id="a-crucial-detail-where-do-these-strings-come-from" class="level3">
<h3 class="anchored" data-anchor-id="a-crucial-detail-where-do-these-strings-come-from">A Crucial Detail: Where do these strings come from?</h3>
<p>You might be asking: <em>“If the matrix <img src="https://latex.codecogs.com/png.latex?A"> is too big to store, how do we calculate this decomposition?”</em></p>
<p>There are two scenarios:</p>
<ol type="1">
<li><p><strong>The Mathematical Route:</strong> If we <em>did</em> have a small arbitrary matrix, we could mathematically decompose it using the <strong>Hilbert-Schmidt inner product</strong>. We project the matrix onto each Pauli basis tensor to find the coefficients <img src="https://latex.codecogs.com/png.latex?c_j">. However, doing this for large <img src="https://latex.codecogs.com/png.latex?N"> defeats the purpose, as we would need to build the giant matrix first.</p></li>
<li><p><strong>The Practical Route (Direct Mapping):</strong> In useful quantum applications (like Chemistry or Optimization), <strong>we never build the dense matrix</strong>.</p>
<ul>
<li><strong>In Chemistry:</strong> The interaction between electrons is described by the <strong>Jordan-Wigner</strong> or <strong>Bravyi-Kitaev</strong> transformations, which map the physical system <em>directly</em> into a sum of Pauli strings (<img src="https://latex.codecogs.com/png.latex?O(n%5E4)"> terms) without ever creating a <img src="https://latex.codecogs.com/png.latex?2%5En%20%5Ctimes%202%5En"> array.</li>
<li><strong>In Optimization (MaxCut):</strong> The cost function of a graph cut maps directly to a sum of <img src="https://latex.codecogs.com/png.latex?Z_i%20Z_j"> terms based on the graph’s edges.</li>
</ul></li>
</ol>
<p>This allows us to work with operators for 50+ qubits (a vector space of <img src="https://latex.codecogs.com/png.latex?10%5E%7B15%7D">) while only storing a polynomial number of Pauli terms in our laptop’s memory.</p>
<blockquote class="blockquote">
<p><strong>Note:</strong> If these transformations sound complex, don’t worry. We will dedicate a future post in this series specifically to <strong>Problem Mapping</strong>—showing exactly how to turn a physical chemistry problem or a logistics graph into these Pauli strings without ever building the giant matrix.</p>
</blockquote>
</section>
<section id="why-this-solves-the-complexity-problem" class="level3">
<h3 class="anchored" data-anchor-id="why-this-solves-the-complexity-problem">Why This Solves the Complexity Problem</h3>
<p>This representation changes the problem from “massive matrix multiplication” to “linear summation.”</p>
<p>Recall that we want to calculate the expectation value <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle">. Using the linearity of expectation, we can break this down:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle%20=%20%5Clangle%20v%20%7C%20%5Cleft(%20%5Csum_j%20c_j%20P_j%20%5Cright)%20%7C%20v%20%5Crangle%20=%20%5Csum_j%20c_j%20%5Clangle%20v%20%7C%20P_j%20%7C%20v%20%5Crangle%0A"></p>
<p>This is the key to the efficiency of the algorithm. We don’t need a quantum computer that can “process” the giant matrix <img src="https://latex.codecogs.com/png.latex?A"> all at once. We only need a quantum computer that can measure simple Pauli terms.</p>
</section>
</section>
<section id="calculating-the-expectation-value" class="level2">
<h2 class="anchored" data-anchor-id="calculating-the-expectation-value">3. Calculating the Expectation Value</h2>
<p>We have defined our vector <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> and decomposed our matrix <img src="https://latex.codecogs.com/png.latex?A">. Now comes the actual computation: calculating <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20P_j%20%7C%20v%20%5Crangle">. How do we actually ask a quantum computer for this number?</p>
<section id="a-the-manual-approach-sampling-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="a-the-manual-approach-sampling-eigenvalues">A) The Manual Approach: Sampling Eigenvalues</h3>
<p>Let’s assume our Hamiltonian is just a single Pauli string, say <img src="https://latex.codecogs.com/png.latex?Z"> on a single qubit. The expectation value is simply the weighted average of outcomes. We run the circuit, measure the qubit, and collect the bitstrings (e.g., <code>0</code>, <code>0</code>, <code>1</code>, <code>0</code>…). mapping <code>0</code> to <img src="https://latex.codecogs.com/png.latex?+1"> and <code>1</code> to <img src="https://latex.codecogs.com/png.latex?-1">.</p>
<p><strong>Why this mapping?</strong> This isn’t arbitrary. It relies on the known spectral properties of Pauli matrices. The computational basis states <img src="https://latex.codecogs.com/png.latex?%7C0%5Crangle"> and <img src="https://latex.codecogs.com/png.latex?%7C1%5Crangle"> are the <strong>eigenstates</strong> of the Pauli <img src="https://latex.codecogs.com/png.latex?Z"> operator, with eigenvalues <img src="https://latex.codecogs.com/png.latex?+1"> and <img src="https://latex.codecogs.com/png.latex?-1"> respectively:</p>
<p><img src="https://latex.codecogs.com/png.latex?Z%7C0%5Crangle%20=%20(+1)%7C0%5Crangle"> <img src="https://latex.codecogs.com/png.latex?Z%7C1%5Crangle%20=%20(-1)%7C1%5Crangle"></p>
<p>When we measure a qubit, we are collapsing it into one of these eigenstates. The value we associate with that outcome is the corresponding eigenvalue.</p>
<p><strong>Extending to Multi-Qubit Terms</strong> Crucially, the eigenvalue of a tensor product of Pauli matrices is simply the <strong>product</strong> of the eigenvalues of each individual matrix.</p>
<p>For example, if we are measuring the operator <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z"> on two qubits and we observe the state <img src="https://latex.codecogs.com/png.latex?%7C01%5Crangle">: * The first qubit is in <img src="https://latex.codecogs.com/png.latex?%7C0%5Crangle"> (eigenvalue <img src="https://latex.codecogs.com/png.latex?+1">). * The second qubit is in <img src="https://latex.codecogs.com/png.latex?%7C1%5Crangle"> (eigenvalue <img src="https://latex.codecogs.com/png.latex?-1">). * The total eigenvalue for this shot is <img src="https://latex.codecogs.com/png.latex?(+1)%20%5Ctimes%20(-1)%20=%20-1">.</p>
<p>This allows us to reconstruct the value of any complex Pauli string simply by multiplying the results of individual qubit measurements.</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Clangle%20Z%20%5Crangle%20%5Capprox%20%5Cfrac%7B(+1)%20%5Ccdot%20N_0%20+%20(-1)%20%5Ccdot%20N_1%7D%7BN_%7Btotal%7D%7D"></p>
<p><strong>What about X and Y?</strong> Quantum hardware generally only measures in the <strong>Z-basis</strong>. If our Pauli string contains an <img src="https://latex.codecogs.com/png.latex?X"> or <img src="https://latex.codecogs.com/png.latex?Y">, we cannot measure it directly. We must apply a basis rotation gate (like a Hadamard for <img src="https://latex.codecogs.com/png.latex?X">) <em>just before</em> measurement to align the axis with <img src="https://latex.codecogs.com/png.latex?Z">.</p>
</section>
<section id="b-the-challenge-the-explosion-of-terms" class="level3">
<h3 class="anchored" data-anchor-id="b-the-challenge-the-explosion-of-terms">B) The Challenge: The Explosion of Terms</h3>
<p>In a real problem, our matrix <img src="https://latex.codecogs.com/png.latex?A"> might contain <strong>thousands</strong> of Pauli terms.</p>
<p><img src="https://latex.codecogs.com/png.latex?H%20=%20c_1%20(Z_0%20Z_1)%20+%20c_2%20(X_0%20X_1)%20+%20c_3%20(Z_0%20I_1)%20+%20%5Cdots"></p>
<p>If we were to run a separate quantum experiment (Sampler job) for every single term, the overhead would be astronomical.</p>
<p><strong>The Solution: Operator Grouping</strong> Fortunately, we can exploit <strong>commutativity</strong>. If two Pauli strings commute (specifically, qubit-wise commutativity), they can be measured in the same basis simultaneously.</p>
<p>For example, <img src="https://latex.codecogs.com/png.latex?Z_0%20Z_1"> and <img src="https://latex.codecogs.com/png.latex?Z_0%20I_1"> both require the Z-basis. We can measure both in a single “shot”. However, <img src="https://latex.codecogs.com/png.latex?Z_0%20Z_1"> and <img src="https://latex.codecogs.com/png.latex?X_0%20X_1"> do <strong>not</strong> commute (Heisenberg’s Uncertainty Principle). You cannot measure Z and X on qubit 0 at the same time.</p>
<p>Therefore, we group the thousands of Pauli strings into a small number of <strong>commuting families</strong>. We run one quantum job per family, effectively compressing thousands of measurements into a few dozen jobs.</p>
</section>
<section id="c-the-abstraction-the-qiskit-estimator" class="level3">
<h3 class="anchored" data-anchor-id="c-the-abstraction-the-qiskit-estimator">C) The Abstraction: The Qiskit Estimator</h3>
<p>Doing this efficiently involves significant bookkeeping: checking commutativity, grouping terms, appending rotations, and aggregating statistics.</p>
<p>In modern Qiskit, this is abstracted away by the <strong>Estimator</strong>. The Estimator is a primitive that takes the Circuit (state) and the Operator (matrix), handles the grouping and rotations internally, and returns the final floating-point expectation value.</p>
</section>
</section>
<section id="code-example-the-estimator-in-action" class="level2">
<h2 class="anchored" data-anchor-id="code-example-the-estimator-in-action">4. Code Example: The Estimator in Action</h2>
<p>Let’s make this concrete. We will not start with quantum gates; we will start with a standard linear algebra problem.</p>
<p><strong>The Classical Problem</strong> Imagine we have a <img src="https://latex.codecogs.com/png.latex?4%20%5Ctimes%204"> Hermitian matrix <img src="https://latex.codecogs.com/png.latex?A"> and a 4-dimensional vector <img src="https://latex.codecogs.com/png.latex?v">, and we want to calculate <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AA%20=%20%5Cbegin%7Bbmatrix%7D%0A0.5%20&amp;%200%20&amp;%200%20&amp;%200.2%20%5C%5C%0A0%20&amp;%20-0.5%20&amp;%200.2%20&amp;%200%20%5C%5C%0A0%20&amp;%200.2%20&amp;%20-0.5%20&amp;%200%20%5C%5C%0A0.2%20&amp;%200%20&amp;%200%20&amp;%200.5%0A%5Cend%7Bbmatrix%7D%0A"></p>
<p>We want to verify the expectation value for a specific normalized vector: <img src="https://latex.codecogs.com/png.latex?%0Av%20%5Capprox%20%5Cbegin%7Bbmatrix%7D%200.80%20%5C%5C%200.46%20%5C%5C%200.33%20%5C%5C%200.19%20%5Cend%7Bbmatrix%7D%0A"></p>
<p>This problem is so small that one could do this on paper to determine that <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Capprox%200.299">. However, we are going to use this example to illustrate how this problem can be mapped to a quantum system and how it produces an output.</p>
<p><strong>1. The Matrix Decomposition:</strong> We cannot load the <img src="https://latex.codecogs.com/png.latex?4%20%5Ctimes%204"> array into the QPU. We must break it down. Looking at the structure of <img src="https://latex.codecogs.com/png.latex?A">: * The diagonal terms correspond to <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z">. * The off-diagonal terms correspond to <img src="https://latex.codecogs.com/png.latex?X%20%5Cotimes%20X">.</p>
<p>We can rewrite <img src="https://latex.codecogs.com/png.latex?A"> exactly as: <img src="https://latex.codecogs.com/png.latex?A%20=%200.5%20(Z%20%5Cotimes%20Z)%20+%200.2%20(X%20%5Cotimes%20X)"></p>
<p><strong>2. The Vector Construction:</strong> Quantum computers always start in the <img src="https://latex.codecogs.com/png.latex?%7C00%5Crangle"> state (the vector <img src="https://latex.codecogs.com/png.latex?%5B1,%200,%200,%200%5D">). We need to build a circuit to transform this into our target vector <img src="https://latex.codecogs.com/png.latex?v">. We can do this using <img src="https://latex.codecogs.com/png.latex?R_Y"> (Rotation-Y) gates.</p>
<ul>
<li>Applying <img src="https://latex.codecogs.com/png.latex?R_Y(%5Cpi/3)"> to qubit 0 creates amplitudes <img src="https://latex.codecogs.com/png.latex?%5Capprox%20%5B0.866,%200.5%5D">.</li>
<li>Applying <img src="https://latex.codecogs.com/png.latex?R_Y(%5Cpi/4)"> to qubit 1 creates amplitudes <img src="https://latex.codecogs.com/png.latex?%5Capprox%20%5B0.924,%200.383%5D">.</li>
</ul>
<p>The tensor product of these rotations results in exactly our target vector <img src="https://latex.codecogs.com/png.latex?%5B0.80,%200.46,%200.33,%200.19%5D">.</p>
<section id="the-quantum-code" class="level3">
<h3 class="anchored" data-anchor-id="the-quantum-code">The Quantum Code</h3>
<p>Now, let’s write the code to implement this mapping and verify the result matches our classical calculation.</p>
<div id="bc550872" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.quantum_info <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SparsePauliOp</span>
<span id="cb1-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorEstimator</span>
<span id="cb1-5"></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. The Matrix A (The Hamiltonian)</span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We define A = 0.5 * (Z on q0, Z on q1) + 0.2 * (X on q0, X on q1)</span></span>
<span id="cb1-8">hamiltonian <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SparsePauliOp.from_list([</span>
<span id="cb1-9">    (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ZZ"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>),  </span>
<span id="cb1-10">    (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"XX"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>)   </span>
<span id="cb1-11">])</span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Operator A:"</span>, end<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">" "</span>)</span>
<span id="cb1-14">print_hamiltonian(hamiltonian)</span>
<span id="cb1-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Operator A: 0.50 * ZZ + 0.20 * XX

</code></pre>
</div>
</div>
<div id="6595d021" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. The Vector |v&gt; (State Preparation)</span></span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We use Ry gates to rotate the qubits from |0&gt; to a superposition.</span></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># using real-valued rotations keeps the amplitudes real.</span></span>
<span id="cb3-4">qc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb3-5">qc.ry(np.pi<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rotate qubit 0 by 60 degrees</span></span>
<span id="cb3-6">qc.ry(np.pi<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rotate qubit 1 by 45 degrees</span></span>
<span id="cb3-7"></span>
<span id="cb3-8"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Circuit representing state |v&gt;:"</span>)</span>
<span id="cb3-9">display(qc.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mpl"</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Circuit representing state |v&gt;:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal_files/figure-html/cell-4-output-2.png" width="170" height="168" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="5e4d73ad" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. The Abstraction (The Estimator)</span></span>
<span id="cb5-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We instantiate the local StatevectorEstimator</span></span>
<span id="cb5-3">estimator <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorEstimator()</span>
<span id="cb5-4"></span>
<span id="cb5-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The estimator handles the basis rotations and operator grouping internally.</span></span>
<span id="cb5-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Run format: run([(circuit, operator)])</span></span>
<span id="cb5-7">job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([(qc, hamiltonian)])</span>
<span id="cb5-8">result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb5-9"></span>
<span id="cb5-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4. The Result</span></span>
<span id="cb5-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># result.data.evs is a NumPy array of expectation values.</span></span>
<span id="cb5-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We access the first element [0] to get our specific scalar result.</span></span>
<span id="cb5-13">expectation_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result.data.evs</span>
<span id="cb5-14"></span>
<span id="cb5-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">Calculated Expectation Value &lt;v|A|v&gt;: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>expectation_value<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Calculated Expectation Value &lt;v|A|v&gt;: 0.299251</code></pre>
</div>
</div>
<p><strong>What just happened?</strong> The Estimator acted as our “Linear Algebra Calculator.”</p>
<ol type="1">
<li><strong>Input:</strong> It took a Circuit (a recipe for creating the vector <img src="https://latex.codecogs.com/png.latex?v">) and an Operator (the decomposition of matrix <img src="https://latex.codecogs.com/png.latex?A">).</li>
<li><strong>Process:</strong> It handled the basis rotations and measurements internally (splitting ZZ and XX into different measurement jobs if needed).</li>
<li><strong>Output:</strong> It returned the scalar value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</li>
</ol>
<p><strong>Next Steps:</strong> In the next post, we will finally close the loop. We will replace our fixed manual angles with <strong>variables</strong>, introducing the <strong>Ansatz</strong>, and use a classical optimization algorithm to find the specific angles that minimize our energy.</p>


</section>
</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Qiskit</category>
  <category>Linear Algebra</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal.html</guid>
  <pubDate>Fri, 05 Dec 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>The Variational Principle: A Linear Algebra Perspective</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/02-variational-principle.html</link>
  <description><![CDATA[ 





<p>In my <a href="https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html">previous post</a>, “Challenge Accepted,” I set the stage for exploring quantum diagonalization. Since then, I’ve been diving deeper into the material, specifically reading the first lesson of the <a href="https://quantum.cloud.ibm.com/learning/en/courses/quantum-diagonalization-algorithms/vqe">IBM Variational Quantum Algorithms course</a>.</p>
<p>As I digested the material, I started thinking about the basic concepts that underpin the Variational Quantum Eigensolver (VQE). It’s easy to get lost in the quantum mechanics immediately, but the heart of the method actually lies in standard linear algebra.</p>
<section id="from-eigenvalues-to-expectation-values" class="level2">
<h2 class="anchored" data-anchor-id="from-eigenvalues-to-expectation-values">From Eigenvalues to Expectation Values</h2>
<p>We traditionally encounter eigenvalues and eigenvectors as the solutions to the characteristic equation:</p>
<p><img src="https://latex.codecogs.com/png.latex?Ax%20=%20%5Clambda%20x"></p>
<p>If we assume our vector <img src="https://latex.codecogs.com/png.latex?x"> is normalized (has a length of 1), we can perform a simple manipulation. By multiplying both sides by the transpose of <img src="https://latex.codecogs.com/png.latex?x"> (denoted as <img src="https://latex.codecogs.com/png.latex?x%5ET">), we can rewrite this relationship to isolate the eigenvalue <img src="https://latex.codecogs.com/png.latex?%5Clambda">:</p>
<p><img src="https://latex.codecogs.com/png.latex?x%5ET%20A%20x%20=%20%5Clambda"></p>
<p>In many problems, particularly in physics and chemistry, we aren’t looking for just <em>any</em> eigenvalue; we are hunting for the <strong>lowest eigenvalue</strong> (the ground state energy). Let’s call this lowest eigenvalue <img src="https://latex.codecogs.com/png.latex?%5Clambda_0">, which corresponds to a specific eigenvector <img src="https://latex.codecogs.com/png.latex?x_0">:</p>
<p><img src="https://latex.codecogs.com/png.latex?x_0%5ET%20A%20x_0%20=%20%5Clambda_0"></p>
<p>This concept can be visualized as a search on a complex energy landscape. Our goal is to navigate this landscape to find the absolute lowest point, the global minimum.</p>
<div id="fig-energy-landscape" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A 3D surface plot showing a complex energy landscape with hills and valleys, highlighting a single global minimum point representing the ground state energy.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-energy-landscape-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" class="img-fluid figure-img" alt="A 3D surface plot showing a complex energy landscape with hills and valleys, highlighting a single global minimum point representing the ground state energy.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-energy-landscape-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Geometric interpretation of an energy landscape, showing optimization paths descending towards the global minimum (ground state).
</figcaption>
</figure>
</div>
<p>This brings us to a fundamental property known as the <strong>Variational Principle</strong>. It states that if you take <em>any</em> arbitrary normalized vector <img src="https://latex.codecogs.com/png.latex?v"> and compute this product, the result will always be greater than or equal to the lowest eigenvalue:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0"></p>
<p>If you are interested in the mathematical rigor behind this principle, you can expand the section below for a step-by-step proof.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Proof: The Variational Principle (Click to expand)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>To prove that <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0">, we rely on the <strong>Spectral Theorem</strong>. Since <img src="https://latex.codecogs.com/png.latex?A"> represents a physical observable (like a Hamiltonian), it is a Hermitian matrix. This guarantees two things:</p>
<ol type="1">
<li>All its eigenvalues <img src="https://latex.codecogs.com/png.latex?%5Clambda_i"> are real.</li>
<li>Its eigenvectors <img src="https://latex.codecogs.com/png.latex?%5C%7Bx_0,%20x_1,%20%5Cdots,%20x_%7Bn-1%7D%5C%7D"> form a complete orthonormal basis.</li>
</ol>
<p>Let’s order the eigenvalues such that <img src="https://latex.codecogs.com/png.latex?%5Clambda_0%20%5Cle%20%5Clambda_1%20%5Cle%20%5Cdots%20%5Cle%20%5Clambda_%7Bn-1%7D">.</p>
<p>Since the eigenvectors form a basis, any arbitrary vector <img src="https://latex.codecogs.com/png.latex?v"> can be written as a linear combination of these eigenvectors:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%20=%20%5Csum_%7Bi%7D%20c_i%20x_i"></p>
<p>Because <img src="https://latex.codecogs.com/png.latex?v"> is normalized (<img src="https://latex.codecogs.com/png.latex?v%5ET%20v%20=%201">) and the basis is orthonormal (<img src="https://latex.codecogs.com/png.latex?x_i%5ET%20x_j%20=%20%5Cdelta_%7Bij%7D">), the sum of the squared coefficients must equal 1:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20=%201"></p>
<p>Now, let’s look at the action of <img src="https://latex.codecogs.com/png.latex?A"> on this expansion:</p>
<p><img src="https://latex.codecogs.com/png.latex?A%20v%20=%20A%20%5Cleft(%20%5Csum_%7Bi%7D%20c_i%20x_i%20%5Cright)%20=%20%5Csum_%7Bi%7D%20c_i%20(A%20x_i)%20=%20%5Csum_%7Bi%7D%20c_i%20%5Clambda_i%20x_i"></p>
<p>Next, we calculate the expectation value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20=%20%5Cleft(%20%5Csum_%7Bj%7D%20c_j%20x_j%20%5Cright)%5ET%20%5Cleft(%20%5Csum_%7Bi%7D%20c_i%20%5Clambda_i%20x_i%20%5Cright)"></p>
<p>Due to the orthonormality of the eigenvectors (the product <img src="https://latex.codecogs.com/png.latex?x_j%5ET%20x_i"> is 1 if <img src="https://latex.codecogs.com/png.latex?i=j"> and 0 otherwise), the cross-terms vanish, leaving us with a weighted sum of the eigenvalues:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20=%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_i"></p>
<p>Here is the crucial step. Since <img src="https://latex.codecogs.com/png.latex?%5Clambda_0"> is the smallest eigenvalue, we know that <img src="https://latex.codecogs.com/png.latex?%5Clambda_i%20%5Cge%20%5Clambda_0"> for all <img src="https://latex.codecogs.com/png.latex?i">. Therefore, we can replace <img src="https://latex.codecogs.com/png.latex?%5Clambda_i"> with <img src="https://latex.codecogs.com/png.latex?%5Clambda_0"> to form an inequality:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_i%20%5Cge%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_0"></p>
<p>We can factor out <img src="https://latex.codecogs.com/png.latex?%5Clambda_0">:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0%20%5Cleft(%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Cright)"></p>
<p>Since <img src="https://latex.codecogs.com/png.latex?%5Csum%20%7Cc_i%7C%5E2%20=%201">, the proof is complete:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0"></p>
</div>
</div>
</div>
</section>
<section id="turning-algebra-into-optimization" class="level2">
<h2 class="anchored" data-anchor-id="turning-algebra-into-optimization">Turning Algebra into Optimization</h2>
<p>This inequality gives us a clear strategy. To find the lowest eigenvalue, we don’t need to analytically solve the matrix equation. Instead, we can treat it as a minimization game: we need to try different vectors <img src="https://latex.codecogs.com/png.latex?v"> until we find the one that produces the lowest possible value for <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>However, trying vectors blindly is not efficient. The vector space is simply too vast. To make this manageable, we transform the search into an <strong>optimization problem</strong>.</p>
<p>Instead of picking random vectors, we construct a vector that depends on a set of tunable scalar parameters. Let’s say we have a problem with <img src="https://latex.codecogs.com/png.latex?n"> dimensions; theoretically, we need at most <img src="https://latex.codecogs.com/png.latex?n"> parameters to explore the space. We can denote this parameterized vector as <img src="https://latex.codecogs.com/png.latex?v(%5Ctheta)">. By tweaking these <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> parameters, we navigate the vector space, searching for the minimum value.</p>
</section>
<section id="the-complexity-barrier-and-the-quantum-solution" class="level2">
<h2 class="anchored" data-anchor-id="the-complexity-barrier-and-the-quantum-solution">The Complexity Barrier and the Quantum Solution</h2>
<p>This sounds straightforward enough to handle classically, so why do we need a quantum computer?</p>
<p>The problem lies in the complexity. As the system we are studying grows (for example, adding more atoms to a molecule), the dimension of the matrix <img src="https://latex.codecogs.com/png.latex?A"> explodes exponentially. For a system that is still relatively small in physical terms, the vector <img src="https://latex.codecogs.com/png.latex?v"> becomes so large that a classical supercomputer cannot even store it, let alone perform the matrix multiplications required to calculate <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>The chart below illustrates this dramatic difference in scaling. While classical resources grow exponentially, a quantum algorithm like VQE offers a much more favorable polynomial scaling.</p>
<div id="fig-complexity" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A line chart on a semi-log scale comparing the exponential growth of classical computational resources against the polynomial growth of quantum VQE resources as the system size increases.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_1.png" class="img-fluid figure-img" alt="A line chart on a semi-log scale comparing the exponential growth of classical computational resources against the polynomial growth of quantum VQE resources as the system size increases.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Comparison of computational resource scaling for classical simulation (exponential) versus Quantum VQE (polynomial) as a function of system size.
</figcaption>
</figure>
</div>
<p>This is where the quantum connection is made. In quantum mechanics, the expression <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v"> is written using Dirac notation as:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle"></p>
<p>This is known as the <strong>quantum expectation value</strong>.</p>
<p>While calculating this is a choking point for classical computers, it is a native operation for a quantum computer. We can prepare the state <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> on a quantum processor and measure the expectation value of the operator <img src="https://latex.codecogs.com/png.latex?A"> directly. This allows us to evaluate our “cost function” efficiently, while a classical computer handles the task of updating the parameters <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> to drive us toward the solution.</p>
<p><strong>Next Steps:</strong> In my next post, I will dive into the implementation details: specifically, how we efficiently create these parameterized vectors (the <em>ansatz</em> - German for ‘approach’ or ‘trial’) on actual quantum hardware, and the precise circuits required to measure the quantum expectation value <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle">.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Linear Algebra</category>
  <category>VQE</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/02-variational-principle.html</guid>
  <pubDate>Sun, 30 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>Challenge Accepted: Mastering Quantum Diagonalization (It’s Not Just for Molecules)</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html</link>
  <description><![CDATA[ 





<p>Yesterday, I attended a Qiskit Advocate seminar on <strong>Sample-Based Quantum Diagonalization (SQD)</strong>. The session was a fascinating deep dive into how we can extract eigenvalues from complex Hamiltonians using advanced sampling techniques. It was a reminder of just how powerful hybrid quantum algorithms are becoming for research.</p>
<p>But it also prompted a personal challenge.</p>
<p>As I watched the presentation, I realized that while I grasp the concepts, I want to get my hands dirty with the implementation details of the foundational solvers that lead up to SQD. To truly appreciate the cutting edge, one must master the building blocks.</p>
<p>So, I am kicking off a new learning sprint. I have officially enrolled in the <a href="https://quantum.cloud.ibm.com/learning/en/courses/quantum-diagonalization-algorithms">IBM Quantum Learning course on Quantum Diagonalization Algorithms</a>. Over the coming weeks, this blog series will serve as my lab notebook—documenting the code, the math, and the results as I attempt to diagonalize matrices on real quantum backends.</p>
<section id="why-diagonalization-matters-beyond-physics" class="level2">
<h2 class="anchored" data-anchor-id="why-diagonalization-matters-beyond-physics">Why “Diagonalization” Matters (Beyond Physics)</h2>
<p>If you look at most quantum computing tutorials, “diagonalization” is almost exclusively framed as a chemistry problem: <em>Find the ground state energy of a molecule.</em></p>
<p>While simulating nature is a killer application, as a Computer Scientist, I want to broaden the aperture. Mathematically, diagonalizing a matrix <img src="https://latex.codecogs.com/png.latex?A"> simply means finding the basis in which <img src="https://latex.codecogs.com/png.latex?A"> acts as a simple scaling factor. We are solving for eigenvectors (<img src="https://latex.codecogs.com/png.latex?v">) and eigenvalues (<img src="https://latex.codecogs.com/png.latex?%5Clambda">):</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AAv%20=%20%5Clambda%20v%0A"></p>
<p>In my view, this isn’t just about electron orbitals. This is about <strong>extracting the defining features of a system</strong>. The algorithms I’ll be exploring in this course—VQE, Quantum Krylov, and Phase Estimation—are actually universal mathematical tools that apply directly to classic CS and Data Science problems:</p>
<section id="graph-theory-spectral-clustering" class="level3">
<h3 class="anchored" data-anchor-id="graph-theory-spectral-clustering">1. Graph Theory &amp; Spectral Clustering</h3>
<p>In social network analysis, we use the <strong>Graph Laplacian</strong> matrix. Diagonalizing this matrix helps us find the “Fiedler Vector,” which tells us the optimal way to cut a graph into disconnected communities. It’s not energy; it’s <em>clustering</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/spectral-cut.png" class="img-fluid figure-img"></p>
<figcaption>A visualization of a Spectral Clustering Cut</figcaption>
</figure>
</div>
</section>
<section id="data-science-pca" class="level3">
<h3 class="anchored" data-anchor-id="data-science-pca">2. Data Science &amp; PCA</h3>
<p>In Machine Learning, <strong>Principal Component Analysis (PCA)</strong> relies on diagonalizing the Covariance Matrix. The eigenvectors with the largest eigenvalues represent the features that matter most in a massive dataset. A quantum eigensolver is effectively a pattern recognition engine.</p>
</section>
<section id="system-dynamics" class="level3">
<h3 class="anchored" data-anchor-id="system-dynamics">3. System Dynamics</h3>
<p>In Markov chains (like the math powering PageRank), the steady state of a system is simply the eigenvector with an eigenvalue of 1.</p>
</section>
</section>
<section id="the-syllabus-my-roadmap" class="level2">
<h2 class="anchored" data-anchor-id="the-syllabus-my-roadmap">The Syllabus: My Roadmap</h2>
<p>This course moves beyond the “Hello World” of quantum. Here is the roadmap of algorithms I plan to implement and stress-test:</p>
<ul>
<li><strong>The Heuristic Layer:</strong> Deep diving into <strong>VQE (Variational Quantum Eigensolver)</strong>, specifically looking at efficient ansatz construction for non-chemistry problems.</li>
<li><strong>The Subspace Layer:</strong> This is the bridge to the seminar I attended. I will be exploring <strong>Quantum Subspace Expansion</strong> and <strong>Krylov methods</strong>, which project large problems into smaller, manageable subspaces.</li>
<li><strong>The Precision Layer:</strong> Finally, looking at <strong>Quantum Phase Estimation (QPE)</strong>, the “textbook” algorithm that offers exponential speedup but demands significant resources.</li>
</ul>
</section>
<section id="the-commitment" class="level2">
<h2 class="anchored" data-anchor-id="the-commitment">The Commitment</h2>
<p>I intend to approach this not just as a student, but as an engineer and educator.</p>
<p>I won’t just post the “happy path” where the code works perfectly on a simulator. I plan to run these algorithms on IBM’s utility-scale quantum systems. I will document the noise, the convergence failures, and the error mitigation strategies (like Zero Noise Extrapolation) required to get a clean signal out of a real device.</p>
<p><strong>Next up:</strong> I’ll be tackling the Graph Laplacian and seeing if we can use a quantum computer to solve a classic clustering problem.</p>


</section>

 ]]></description>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html</guid>
  <pubDate>Wed, 26 Nov 2025 05:00:00 GMT</pubDate>
</item>
<item>
  <title>The Quantum Pigeonhole Paradox in Qiskit 2.x</title>
  <dc:creator>Dikran Meliksetian</dc:creator>
  <link>https://dikranmeliksetian.com/posts/quantum-pigeonhole/</link>
  <description><![CDATA[ 





<p>I have released a new tutorial exploring one of the most counter-intuitive results in quantum mechanics: <strong>The Quantum Pigeonhole Paradox</strong>.</p>
<p>Classically, the <strong>Pigeonhole Principle</strong> states that if you put three pigeons into two boxes, at least one box must contain more than one pigeon. In the quantum realm, however, using <strong>pre-selection</strong> and <strong>post-selection</strong>, we can construct a scenario where we can verify that <strong>no two particles share a box</strong>.</p>
<section id="what-this-tutorial-covers" class="level3">
<h3 class="anchored" data-anchor-id="what-this-tutorial-covers">What this Tutorial Covers</h3>
<p>In this <a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox">Qiskit 2.x notebook</a>, we explore:</p>
<ol type="1">
<li><strong>The Paradox Setup:</strong> Constructing the circuit for three particles and two boxes (states <img src="https://latex.codecogs.com/png.latex?%7CL%5Crangle"> and <img src="https://latex.codecogs.com/png.latex?%7CR%5Crangle">).</li>
<li><strong>The Measurement Problem:</strong> Demonstrating how a standard “strong” measurement collapses the state and destroys the paradox.</li>
<li><strong>Weak Measurements:</strong> Using a weak, reversible probe (Compute <img src="https://latex.codecogs.com/png.latex?%5Crightarrow%20R_y(%5Cepsilon)%20%5Crightarrow"> Uncompute) to extract information without collapsing the interference pattern.</li>
<li><strong>Interference Recovery:</strong> Observing how the paradox re-emerges when we limit the disturbance to the system.</li>
</ol>
</section>
<section id="key-insight" class="level3">
<h3 class="anchored" data-anchor-id="key-insight">Key Insight</h3>
<p>This paradox forces us to reconsider the nature of trajectories and correlations in quantum systems. It demonstrates that “logic” about the past (e.g., “which box were they in?”) depends heavily on the measurement strength and the post-selection choice.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Run the Code
</div>
</div>
<div class="callout-body-container callout-body">
<p>This tutorial is open-source and compatible with <strong>Qiskit 2.x</strong>. You can view the full derivation and run the simulation yourself.</p>
</div>
</div>
<div class="grid">
<div class="g-col-12 g-col-md-6">
<p><a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox" class="btn btn-outline-primary w-100"><i class="bi bi-github"></i> View on GitHub</a></p>
</div>
<div class="g-col-12 g-col-md-6">
<p><a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox/blob/main/quantum_pigeonhole_paradox_qiskit_tutorial.ipynb" class="btn btn-primary w-100"><i class="bi bi-journal-code"></i> Read the Notebook</a></p>
</div>
</div>
<p><strong>Citation:</strong> &gt; Dikran Meliksetian, <em>The Quantum Pigeonhole Paradox in Qiskit 2.x: From Strong to Weak Measurements</em>, DOI: <a href="https://doi.org/10.5281/zenodo.17387139">10.5281/zenodo.17387139</a>.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Qiskit</category>
  <category>Weak Measurements</category>
  <category>Paradoxes</category>
  <guid>https://dikranmeliksetian.com/posts/quantum-pigeonhole/</guid>
  <pubDate>Tue, 25 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum-pigeonhole/review.png" medium="image" type="image/png" height="46" width="144"/>
</item>
<item>
  <title>Welcome to My Research Blog</title>
  <dc:creator>Dikran Meliksetian, Ph.D.</dc:creator>
  <link>https://dikranmeliksetian.com/posts/welcome/</link>
  <description><![CDATA[ 





<p>Welcome to my personal research blog.</p>
<p>After a career driving technical strategy as a Chief Architect and IBM Master Inventor, and now investigating the frontiers of computer science in academia, I find that the most interesting problems lie at the intersection of theory and practice.</p>
<section id="focus-areas" class="level2">
<h2 class="anchored" data-anchor-id="focus-areas">Focus Areas</h2>
<p>This blog serves as a digital notebook for my ongoing research and intellectual explorations. You can expect technical deep dives and reflections on:</p>
<ol type="1">
<li><p><strong>Quantum Frontiers &amp; QML:</strong> Exploring the transition from classical to quantum architectures. I will be discussing developments in Quantum Error Correction and Qiskit, with a specific focus on how <strong>AI and Machine Learning</strong> are being used to optimize quantum circuits and mitigate noise.</p></li>
<li><p><strong>The Architecture of Innovation:</strong> Reflections on patenting, system design, and the methodologies that turn abstract ideas into scalable technologies. I will explore how Generative AI acts as a catalyst for invention and how it is fundamentally altering the software development lifecycle.</p></li>
<li><p><strong>The AI-Augmented Workflow:</strong> Beyond the technology itself, I am interested in the <em>meta-analysis</em> of work. How are Large Language Models (LLMs) changing the way we code, write, and research? I will be documenting how AI is reshaping my own professional practices—from accelerating code generation to assisting in complex problem decomposition.</p></li>
</ol>
</section>
<section id="join-the-conversation" class="level2">
<h2 class="anchored" data-anchor-id="join-the-conversation">Join the Conversation</h2>
<p>I intend for this space to foster discussion with fellow researchers, industry practitioners, and anyone fascinated by the capabilities and limitations of computing systems.</p>
<p>I welcome your insights and feedback on these topics.</p>
<footer id="contact" class="bg-slate-800 text-slate-100 py-16">
<div class="container mx-auto px-6 text-center">
<pre><code>&lt;h2 class="text-3xl font-bold mb-4"&gt;Get In Touch&lt;/h2&gt;
&lt;p class="max-w-xl mx-auto mb-8"&gt;I am always open to discussing new ideas, research opportunities, or interesting projects in the quantum computing space. Feel free to reach out.&lt;/p&gt;

&lt;div class="flex justify-center items-center flex-wrap gap-x-8 gap-y-4 text-lg mb-8"&gt;
  &lt;a href="mailto:dsmeliks@gmail.com" class="flex items-center space-x-2 hover:text-brand-light transition-colors"&gt;
    &lt;i class="fas fa-envelope w-6"&gt;&lt;/i&gt;
    &lt;span&gt;dikran.s.meliksetian@gmail.com (Personal)&lt;/span&gt;
  &lt;/a&gt;
  
  &lt;a href="mailto:dmeliksetian@newhaven.edu" class="flex items-center space-x-2 hover:text-brand-light transition-colors"&gt;
    &lt;i class="fas fa-university w-6"&gt;&lt;/i&gt;
    &lt;span&gt;dmeliksetian@newhaven.edu (Academic)&lt;/span&gt;
  &lt;/a&gt;
  
  &lt;div class="flex items-center space-x-2"&gt;
    &lt;i class="fas fa-map-marker-alt w-6"&gt;&lt;/i&gt;
    &lt;span&gt;Newtown, CT&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p class="text-sm text-slate-400"&gt;&amp;copy; &lt;span id="year"&gt;&lt;/span&gt; Dikran Meliksetian. All Rights Reserved.&lt;/p&gt;</code></pre>
</div>
</footer>
<script>
  const yearSpan = document.getElementById('year');
  if (yearSpan) {
    yearSpan.textContent = new Date().getFullYear();
  }
</script>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Generative AI</category>
  <category>Innovation</category>
  <category>Productivity</category>
  <guid>https://dikranmeliksetian.com/posts/welcome/</guid>
  <pubDate>Sun, 23 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/welcome/welcome_image.png" medium="image" type="image/png" height="79" width="144"/>
</item>
</channel>
</rss>
