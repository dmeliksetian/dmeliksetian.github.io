<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Dikran Meliksetian, Ph.D.</title>
<link>https://dikranmeliksetian.com/blog.html</link>
<atom:link href="https://dikranmeliksetian.com/blog.xml" rel="self" type="application/rss+xml"/>
<description>Personal academic portfolio and research blog exploring Quantum Computing, Qiskit, and Software Architecture.</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Sun, 18 Jan 2026 05:00:00 GMT</lastBuildDate>
<item>
  <title>Exploring the Ansatz Zoo: Heuristics and the Parameter Gap</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/06-exploring-the-ansatz-zoo.html</link>
  <description><![CDATA[ 





<p>In our <strong><a href="../../posts/quantum_diagonalization/05-art-of-the-ansatz.html">previous post</a></strong>, we hit a theoretical wall.</p>
<p>We calculated that to fully parameterize a unique quantum state for <img src="https://latex.codecogs.com/png.latex?N"> qubits, we need:</p>
<p><img src="https://latex.codecogs.com/png.latex?%20%5Ctext%7BParams%7D_%7B%5Ctext%7BFull%7D%7D%20=%202(2%5EN)%20-%202%20"></p>
<p>For a practical <img src="https://latex.codecogs.com/png.latex?N=16"> system, this means searching a <strong>130,000-dimensional</strong> space. No optimizer can handle that. We need to be smarter. We need a “Heuristic Ansatz”—a circuit template that explores a relevant slice of the Hilbert space using a manageable number of parameters.</p>
<section id="the-blueprint-n_local" class="level2">
<h2 class="anchored" data-anchor-id="the-blueprint-n_local">1. The Blueprint: <code>n_local</code></h2>
<p>The general strategy for building these templates is the <strong>n-local</strong> architecture. It consists of alternating layers:</p>
<ol type="1">
<li><p><strong>Rotation Layers:</strong> Single-qubit gates (like <img src="https://latex.codecogs.com/png.latex?R_Y,%20R_Z">) to explore local states.</p></li>
<li><p><strong>Entanglement Layers:</strong> Multi-qubit gates to mix information.</p></li>
</ol>
<p>The term “<img src="https://latex.codecogs.com/png.latex?n">-local” refers to the size of the entangling blocks. The gates act on at most <img src="https://latex.codecogs.com/png.latex?n"> qubits at a time. In Qiskit, the <code>n_local()</code> function allows us to build any variation of this structure.</p>
<section id="the-road-less-traveled-a-3-local-example" class="level3">
<h3 class="anchored" data-anchor-id="the-road-less-traveled-a-3-local-example">The Road Less Traveled: A 3-Local Example</h3>
<p>Most standard ansatzes are <strong>2-local</strong> (using pairs of qubits). But to understand why, let’s try to build a <strong>3-local</strong> circuit.</p>
<p>We could use a 3-qubit gate, like the <strong>Toffoli (CCX)</strong>, as our entangler.</p>
<div id="8eaa9d94" class="cell" data-execution_count="1">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.circuit.library <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> n_local</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit</span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Building a 3-Local Ansatz</span></span>
<span id="cb1-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rotations: RY on every qubit</span></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Entanglement: CCX (Toffoli) acting on triplets</span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We use reps=3 to give it depth</span></span>
<span id="cb1-8">ansatz_3local <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> n_local(num_qubits<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,</span>
<span id="cb1-9">                        rotation_blocks<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ry'</span>],</span>
<span id="cb1-10">                        entanglement_blocks<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ccx'</span>,</span>
<span id="cb1-11">                        entanglement<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>], [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>]], <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Explicit triplets</span></span>
<span id="cb1-12">                        reps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>,</span>
<span id="cb1-13">                        insert_barriers<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb1-14"></span>
<span id="cb1-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"3-Local Parameters: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>ansatz_3local<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>num_parameters<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb1-16">display(ansatz_3local.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mpl'</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>3-Local Parameters: 16</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/06-exploring-the-ansatz-zoo_files/figure-html/cell-2-output-2.png" width="1097" height="291" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="why-dont-we-use-this" class="level3">
<h3 class="anchored" data-anchor-id="why-dont-we-use-this">Why don’t we use this?</h3>
<p>You rarely see 3-local (or 4-local) ansatzes in VQE. There are two main reasons:</p>
<ol type="1">
<li><p><strong>Hardware Connectivity:</strong> Real quantum processors (like IBM’s heavy-hex lattice) only physically connect qubits in pairs. A 3-qubit gate like <code>CCX</code> doesn’t exist natively. The compiler has to break it down into <strong>6+ CNOT gates</strong>, making the circuit incredibly deep and noisy.</p></li>
<li><p><strong>Overkill:</strong> We don’t <em>need</em> 3-body gates to create global entanglement. A layer of 2-body CNOTs can spread information across the entire chip in just a few steps (<img src="https://latex.codecogs.com/png.latex?O(%5Clog%20N)"> depth).</p></li>
</ol>
</section>
</section>
<section id="the-standard-2-local" class="level2">
<h2 class="anchored" data-anchor-id="the-standard-2-local">2. The Standard: 2-Local</h2>
<p>This is why the <strong>2-local</strong> structure is the gold standard. It matches the native hardware (CNOT/CZ) and is expressive enough to generate complex states.</p>
<p>While we can use <code>n_local</code> to build them, Qiskit provides optimized helper functions for the two most common patterns: <code>efficient_su2</code> and <code>real_amplitudes</code>.</p>
<section id="efficient_su2-the-generalist" class="level3">
<h3 class="anchored" data-anchor-id="efficient_su2-the-generalist"><code>efficient_su2</code>: The Generalist</h3>
<p>The <code>efficient_su2</code> ansatz is designed to be <strong>universal for local operations</strong>. “SU(2)” refers to the group of operations on a single qubit. This circuit ensures that every qubit can reach <em>any</em> state on its Bloch sphere (using <img src="https://latex.codecogs.com/png.latex?R_Y"> and <img src="https://latex.codecogs.com/png.latex?R_Z">) before being entangled.</p>
<ul>
<li><p><strong>Best for:</strong> Problems with complex eigenvectors (e.g., non-Hermitian matrices, dynamics).</p></li>
<li><p><strong>Structure:</strong> <img src="https://latex.codecogs.com/png.latex?R_Y%20%5Cto%20R_Z%20%5Cto%20%5Ctext%7BCNOT%7D">.</p></li>
</ul>
<div id="3fa0428a" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.circuit.library <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> efficient_su2</span>
<span id="cb3-2"></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Standard EfficientSU2 with reps=3</span></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This creates 3 full layers of entanglement</span></span>
<span id="cb3-5">ansatz_su2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> efficient_su2(num_qubits<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,</span>
<span id="cb3-6">                           su2_gates<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ry'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'rz'</span>],</span>
<span id="cb3-7">                           entanglement<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'linear'</span>,</span>
<span id="cb3-8">                           reps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb3-9"></span>
<span id="cb3-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"EfficientSU2 Parameters: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>ansatz_su2<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>num_parameters<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb3-11">display(ansatz_su2.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mpl'</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>EfficientSU2 Parameters: 32</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/06-exploring-the-ansatz-zoo_files/figure-html/cell-3-output-2.png" width="1035" height="291" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="parameter-count-n16" class="level4">
<h4 class="anchored" data-anchor-id="parameter-count-n16">Parameter Count (N=16)</h4>
<p>For a 16-qubit system with depth 3: <img src="https://latex.codecogs.com/png.latex?%20%5Ctext%7BParams%7D%20=%202N(d+1)%20=%202(16)(4)%20=%20128%20"> We have reduced the problem from 130,000 variables to <strong>128</strong>.</p>
</section>
</section>
<section id="real_amplitudes-the-specialist" class="level3">
<h3 class="anchored" data-anchor-id="real_amplitudes-the-specialist"><code>real_amplitudes</code>: The Specialist</h3>
<p>For <strong>Matrix Diagonalization</strong> of real symmetric matrices (our main goal), we know the eigenvectors are real. We can strip out the <img src="https://latex.codecogs.com/png.latex?R_Z"> gates. This reduces the parameter count by half, making the optimization easier.</p>
<ul>
<li><p><strong>Best for:</strong> Hamiltonian ground states, Machine Learning kernels, Real Symmetric matrices.</p></li>
<li><p><strong>Structure:</strong> <img src="https://latex.codecogs.com/png.latex?R_Y%20%5Cto%20%5Ctext%7BCNOT%7D">.</p></li>
</ul>
<div id="436aa52a" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.circuit.library <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> real_amplitudes</span>
<span id="cb5-2"></span>
<span id="cb5-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Standard RealAmplitudes with reps=3</span></span>
<span id="cb5-4">ansatz_real <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> real_amplitudes(num_qubits<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>,</span>
<span id="cb5-5">                              entanglement<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'linear'</span>,</span>
<span id="cb5-6">                              reps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb5-7"></span>
<span id="cb5-8"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"RealAmplitudes Parameters: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>ansatz_real<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>num_parameters<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb5-9">display(ansatz_real.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'mpl'</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>RealAmplitudes Parameters: 16</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/06-exploring-the-ansatz-zoo_files/figure-html/cell-4-output-2.png" width="788" height="291" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="parameter-count-n16-1" class="level4">
<h4 class="anchored" data-anchor-id="parameter-count-n16-1">Parameter Count (N=16)</h4>
<p>For a 16-qubit system with depth 3: <img src="https://latex.codecogs.com/png.latex?%20%5Ctext%7BParams%7D%20=%20N(d+1)%20=%2016(4)%20=%2064%20"> <strong>64 variables</strong> is incredibly lightweight. This gives our optimizer the best possible chance of success.</p>
</section>
</section>
</section>
<section id="the-goldilocks-choice-why-reps3" class="level2">
<h2 class="anchored" data-anchor-id="the-goldilocks-choice-why-reps3">3. The Goldilocks Choice: Why <code>reps=3</code>?</h2>
<p>In all the examples above, we set <code>reps=3</code>. This wasn’t an accident. In heuristic ansatz design, the number of repetitions (depth) is the most critical knob we can turn.</p>
<p>It represents a trade-off between <strong>Expressibility</strong> and <strong>Trainability</strong>.</p>
<ol type="1">
<li><p><strong>Too Shallow (<code>reps=0</code> or <code>1</code>):</strong> The circuit cannot create enough entanglement. It can only explore “Product States” or very simple correlations. It will likely fail to reach the true ground state.</p></li>
<li><p><strong>Too Deep (<code>reps=50</code>):</strong></p>
<ul>
<li><strong>Noise:</strong> Every additional layer adds CNOT gates. On current hardware, deep circuits accumulate so much noise that the signal becomes garbage.</li>
<li><strong>Barren Plateaus:</strong> As we add parameters, the high-dimensional optimization landscape becomes increasingly flat. The gradient vanishes, and the optimizer gets stuck.</li>
</ul></li>
<li><p><strong>Just Right (<code>reps=3</code>):</strong> For many practical problems, 3 layers provide enough entanglement to capture non-trivial correlations, while keeping the parameter count low enough (e.g., 64 vs 1000s) for the classical optimizer to succeed.</p></li>
</ol>
</section>
<section id="the-road-not-taken-specialized-ansatzes" class="level2">
<h2 class="anchored" data-anchor-id="the-road-not-taken-specialized-ansatzes">4. The Road Not Taken: Specialized Ansatzes</h2>
<p>The ansatzes above are “blind”—they don’t know what problem they are solving. They just explore the space.</p>
<p>In some fields, we can do better by building the circuit based on the problem’s physics. We mention them here for completeness, though we won’t use them for general diagonalization.</p>
<ol type="1">
<li><p><strong>UCCSD (Unitary Coupled Cluster):</strong> Used in <strong>Chemistry</strong>. The gates mimic electron excitations. It is incredibly accurate but produces very deep circuits that are hard to run on near-term hardware.</p></li>
<li><p><strong>QAOA (Quantum Approximate Optimization Algorithm):</strong> Used in <strong>Combinatorial Optimization</strong> (e.g., MaxCut). The gates alternate between the “Cost Hamiltonian” and a “Mixer,” effectively simulating a time-evolution process.</p></li>
<li><p><strong>ZZFeatureMap:</strong> Used in <strong>Machine Learning</strong>. This is used to encode classical data into quantum states (kernels) rather than finding ground states.</p></li>
</ol>
<p><strong>Why don’t we use them here?</strong> Because we are solving a <strong>general</strong> linear algebra problem. We don’t have the physical intuition of a molecule or a graph to guide us. Therefore, the <strong>Hardware Efficient Ansatz</strong> (<code>real_amplitudes</code>) is our best general-purpose tool.</p>
</section>
<section id="whats-next" class="level2">
<h2 class="anchored" data-anchor-id="whats-next">5. What’s Next?</h2>
<p>We have our Ansatz (<code>real_amplitudes</code>) and our strategy (<code>VQE</code>). But there is a glaring hole in our pipeline.</p>
<p>In all our examples so far, we have been “building” the matrix <img src="https://latex.codecogs.com/png.latex?A"> manually in Python (e.g., creating a NumPy array). But if <img src="https://latex.codecogs.com/png.latex?N=16">, the matrix has <strong>4 billion entries</strong>. We cannot store that in RAM to convert it into a Hamiltonian.</p>
<p>In the next post, we will learn how to represent the matrix <strong>implicitly</strong>—decomposing a problem into Pauli strings without ever building the full dense matrix.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>VQE</category>
  <category>Ansatz</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/06-exploring-the-ansatz-zoo.html</guid>
  <pubDate>Sun, 18 Jan 2026 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/ansatz_zoo.png" medium="image" type="image/png" height="79" width="144"/>
</item>
<item>
  <title>The Art of the Ansatz: Entanglement and the Hilbert Space Wall</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/05-art-of-the-ansatz.html</link>
  <description><![CDATA[ 





<p>In our <strong><a href="../../posts/quantum_diagonalization/04-closing-the-loop.html">previous post</a></strong>, we built a hybrid optimization loop that successfully minimized the energy of our quantum circuit. However, when we compared our result to the classical truth, we hit a snag.</p>
<p>The <strong>Quantum Vector Distance</strong> between our result and the true ground state was significant (around <code>0.76</code>).</p>
<p>Why did it fail? The classical calculation revealed that the true ground state for our Hamiltonian was the <strong>Bell State</strong> <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D(%7C01%5Crangle%20-%20%7C10%5Crangle)">. This is a <strong>maximally entangled</strong> state.</p>
<p>Our previous circuit used only independent rotations (<code>RY</code> on qubit 0, <code>RY</code> on qubit 1). Mathematically, a tensor product of single qubits can <strong>never</strong> create an entangled state. No matter how much the classical optimizer tuned the angles, the quantum computer was physically incapable of reaching the solution.</p>
<section id="the-fix-adding-entanglement" class="level2">
<h2 class="anchored" data-anchor-id="the-fix-adding-entanglement">1. The Fix: Adding Entanglement</h2>
<p>The failure wasn’t an issue with the optimizer; it was an issue with the <strong>Ansatz</strong> (the circuit structure). We tried to fit a round peg (an entangled ground state) into a square hole (a product-state circuit).</p>
<p>To fix this, we need to allow the qubits to talk to each other. We do this by adding a <strong>CNOT (CX)</strong> gate after the rotations. This transforms our circuit from a simple tensor product into a state where the value of qubit 1 depends on qubit 0.</p>
<section id="implementing-the-entangled-ansatz" class="level3">
<h3 class="anchored" data-anchor-id="implementing-the-entangled-ansatz">Implementing the Entangled Ansatz</h3>
<p>Let’s rebuild the circuit, this time appending a <code>cx(0, 1)</code> gate.</p>
<div id="b0096530" class="cell" data-execution_count="1">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.circuit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Parameter</span>
<span id="cb1-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.quantum_info <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SparsePauliOp</span>
<span id="cb1-5"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorEstimator</span>
<span id="cb1-6"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> scipy.optimize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> minimize</span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Re-defining the Hamiltonian from the previous post</span></span>
<span id="cb1-9">hamiltonian <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SparsePauliOp.from_list([(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ZZ"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>), (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"XX"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>)])</span>
<span id="cb1-10">estimator <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorEstimator()</span>
<span id="cb1-11"></span>
<span id="cb1-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Define Parameters</span></span>
<span id="cb1-13">theta_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ0'</span>)</span>
<span id="cb1-14">theta_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ1'</span>)</span>
<span id="cb1-15"></span>
<span id="cb1-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Build the Entangled Ansatz</span></span>
<span id="cb1-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># RY rotations followed by a CNOT entangler</span></span>
<span id="cb1-18">qc_entangled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb1-19">qc_entangled.ry(theta_0, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb1-20">qc_entangled.ry(theta_1, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb1-21">qc_entangled.cx(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- The magic ingredient</span></span>
<span id="cb1-22"></span>
<span id="cb1-23"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Entangled Ansatz:"</span>)</span>
<span id="cb1-24">display(qc_entangled.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mpl"</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Entangled Ansatz:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/05-art-of-the-ansatz_files/figure-html/cell-2-output-2.png" width="232" height="168" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="running-the-optimization-again" class="level3">
<h3 class="anchored" data-anchor-id="running-the-optimization-again">Running the Optimization Again</h3>
<p>We use the exact same Hamiltonian (<img src="https://latex.codecogs.com/png.latex?A">) and the exact same optimizer (COBYLA). The only thing changing is the circuit <code>qc_entangled</code>.</p>
<div id="82b58be4" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define a new cost function using the entangled circuit</span></span>
<span id="cb3-2"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> cost_function_entangled(params):</span>
<span id="cb3-3">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Bind parameters to the NEW circuit</span></span>
<span id="cb3-4">    pub <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (qc_entangled, hamiltonian, params)</span>
<span id="cb3-5">    job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([pub])</span>
<span id="cb3-6">    result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb3-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(result.data.evs)</span>
<span id="cb3-8"></span>
<span id="cb3-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Run Optimization</span></span>
<span id="cb3-10">initial_guess <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>]</span>
<span id="cb3-11">result_entangled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> minimize(cost_function_entangled, initial_guess, method<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'COBYLA'</span>)</span>
<span id="cb3-12"></span>
<span id="cb3-13">optimal_angles_entangled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result_entangled.x</span>
<span id="cb3-14">min_eigenvalue_entangled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result_entangled.fun</span>
<span id="cb3-15"></span>
<span id="cb3-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Check against the true value</span></span>
<span id="cb3-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># For H = 0.5*ZZ + 0.2*XX, the eigenvalues are +/- 0.7 and +/- 0.3</span></span>
<span id="cb3-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The minimum is exactly -0.7</span></span>
<span id="cb3-19">true_eigenvalue <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span> </span>
<span id="cb3-20"></span>
<span id="cb3-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Optimization Complete (Entangled)!"</span>)</span>
<span id="cb3-22"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Minimum Eigenvalue found: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>min_eigenvalue_entangled<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb3-23"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Classical Truth:          </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>true_eigenvalue<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization Complete (Entangled)!
Minimum Eigenvalue found: -0.700000
Classical Truth:          -0.700000</code></pre>
</div>
</div>
<p><strong>The Result:</strong> With just one added gate, the optimizer accessed the “Entangled Subspace” of the Hilbert space, finding the solution that was previously impossible to reach.</p>
</section>
</section>
<section id="verifying-the-eigenvector" class="level2">
<h2 class="anchored" data-anchor-id="verifying-the-eigenvector">2. Verifying the Eigenvector</h2>
<p>The energy looks correct, but we must verify the state itself. Did we actually produce the Bell State? We will use the <code>StatevectorSampler</code> to reconstruct the vector magnitudes from the probabilities and compare it to the known truth.</p>
<div id="c7f117be" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorSampler</span>
<span id="cb5-2"></span>
<span id="cb5-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Prepare the Circuit for Sampling</span></span>
<span id="cb5-4">qc_entangled_sampled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> qc_entangled.copy()</span>
<span id="cb5-5">qc_entangled_sampled.measure_all()</span>
<span id="cb5-6"></span>
<span id="cb5-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Run the Sampler using the OPTIMAL angles</span></span>
<span id="cb5-8">sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorSampler()</span>
<span id="cb5-9">job_sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sampler.run([(qc_entangled_sampled, optimal_angles_entangled)])</span>
<span id="cb5-10">result_sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job_sampler.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb5-11"></span>
<span id="cb5-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Reconstruct the Vector</span></span>
<span id="cb5-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Get counts and convert to probabilities</span></span>
<span id="cb5-14">counts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result_sampler.data.meas.get_counts()</span>
<span id="cb5-15">total_shots <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(counts.values())</span>
<span id="cb5-16"></span>
<span id="cb5-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We strictly order the states: |00&gt;, |01&gt;, |10&gt;, |11&gt;</span></span>
<span id="cb5-18">states <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'00'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'01'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'10'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'11'</span>]</span>
<span id="cb5-19"></span>
<span id="cb5-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate Probabilities</span></span>
<span id="cb5-21">probs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([counts.get(s, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> total_shots <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> s <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> states])</span>
<span id="cb5-22"></span>
<span id="cb5-23"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate Amplitudes (Sqrt of probability)</span></span>
<span id="cb5-24">quantum_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.sqrt(probs)</span>
<span id="cb5-25"></span>
<span id="cb5-26"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define the true vector magnitude (Bell State) for comparison</span></span>
<span id="cb5-27"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The ground state corresponds to (|01&gt; - |10&gt;) / sqrt(2)</span></span>
<span id="cb5-28">true_vector_abs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>np.sqrt(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span>np.sqrt(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>), <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>])</span>
<span id="cb5-29"></span>
<span id="cb5-30"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Reconstructed Quantum Eigenvector:"</span>)</span>
<span id="cb5-31"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(quantum_vector)</span>
<span id="cb5-32"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"-"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>)</span>
<span id="cb5-33"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Quantum Vector Distance: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>np<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>linalg<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>norm(quantum_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> true_vector_abs)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Reconstructed Quantum Eigenvector:
[0.         0.71602745 0.69807212 0.        ]
------------------------------
Quantum Vector Distance: 0.012697</code></pre>
</div>
</div>
<p>Excellent! The distance is now extremely close to zero. By adding the CNOT gate, our Ansatz was able to capture the entanglement required by the solution.</p>
</section>
<section id="stress-testing-the-ansatz" class="level2">
<h2 class="anchored" data-anchor-id="stress-testing-the-ansatz">3. Stress Testing the Ansatz</h2>
<p>We have successfully solved the Bell State problem. This raises an important question: <strong>Can this Ansatz solve <em>any</em> 4x4 symmetric real matrix?</strong></p>
<p>Our circuit has successfully captured entanglement, so intuitively, it seems robust. Let’s put it to the test with a “Counterexample Matrix” designed specifically to break it.</p>
<section id="the-counterexample" class="level3">
<h3 class="anchored" data-anchor-id="the-counterexample">The Counterexample</h3>
<p>We will construct a matrix where the ground state is the vector <img src="https://latex.codecogs.com/png.latex?v%20=%20%5Cfrac%7B1%7D%7B%5Csqrt%7B3%7D%7D(%7C00%5Crangle%20+%20%7C01%5Crangle%20+%20%7C10%5Crangle)">. Notice that the last component (<img src="https://latex.codecogs.com/png.latex?%7C11%5Crangle">) is exactly zero.</p>
<p>Mathematically, our current Ansatz (Rotation <img src="https://latex.codecogs.com/png.latex?%5Cto"> CNOT) forces a specific relationship between the amplitudes: <img src="https://latex.codecogs.com/png.latex?v_%7B00%7D%20%5Ccdot%20v_%7B11%7D%20=%20v_%7B01%7D%20%5Ccdot%20v_%7B10%7D">. For our target vector, <img src="https://latex.codecogs.com/png.latex?1%20%5Ccdot%200%20%5Cneq%201%20%5Ccdot%201">. This vector is mathematically impossible for our current circuit to generate.</p>
<p>Let’s see the optimizer fail in real-time.</p>
<div id="26992c42" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Define the "Unsolvable" Hamiltonian</span></span>
<span id="cb7-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Ground State: |v&gt; = [1, 1, 1, 0] / sqrt(3)</span></span>
<span id="cb7-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We create a projector H = -|v&gt;&lt;v|</span></span>
<span id="cb7-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The minimum eigenvalue is exactly -1.0</span></span>
<span id="cb7-5">matrix_unsolvable <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([</span>
<span id="cb7-6">    [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>],</span>
<span id="cb7-7">    [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>],</span>
<span id="cb7-8">    [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>],</span>
<span id="cb7-9">    [ <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,    <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,    <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb7-10">])</span>
<span id="cb7-11">hamiltonian_hard <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SparsePauliOp.from_operator(matrix_unsolvable)</span>
<span id="cb7-12"></span>
<span id="cb7-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Reuse the Same Ansatz (RY-RY-CNOT)</span></span>
<span id="cb7-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We recreate it to ensure fresh parameters</span></span>
<span id="cb7-15">theta_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ0'</span>)</span>
<span id="cb7-16">theta_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ1'</span>)</span>
<span id="cb7-17">qc_hard <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb7-18">qc_hard.ry(theta_0, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb7-19">qc_hard.ry(theta_1, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb7-20">qc_hard.cx(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) </span>
<span id="cb7-21"></span>
<span id="cb7-22"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Optimize</span></span>
<span id="cb7-23"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> cost_function_hard(params):</span>
<span id="cb7-24">    pub <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (qc_hard, hamiltonian_hard, params)</span>
<span id="cb7-25">    job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([pub])</span>
<span id="cb7-26">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>].data.evs)</span>
<span id="cb7-27"></span>
<span id="cb7-28">result_hard <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> minimize(cost_function_hard, [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>], method<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'COBYLA'</span>)</span>
<span id="cb7-29"></span>
<span id="cb7-30"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Target Eigenvalue:       -1.0000"</span>)</span>
<span id="cb7-31"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Best Value Found:        </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>result_hard<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>fun<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.4f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb7-32"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Error (Gap):             </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(result_hard.fun <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> (<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span>))<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.4f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Target Eigenvalue:       -1.0000
Best Value Found:        -0.8727
Error (Gap):             0.1273</code></pre>
</div>
</div>
<p><strong>The Failure:</strong> The optimizer gets stuck (likely around <code>-0.66</code> or <code>-0.33</code>). It cannot reach <code>-1.0</code> because the solution lies in the “blind spot” of our Ansatz.</p>
</section>
</section>
<section id="the-conceptual-fix-degrees-of-freedom" class="level2">
<h2 class="anchored" data-anchor-id="the-conceptual-fix-degrees-of-freedom">4. The Conceptual Fix: Degrees of Freedom</h2>
<p>Why did it fail? It comes down to counting parameters.</p>
<p>A normalized real vector in 4 dimensions has <strong>3 degrees of freedom</strong>:</p>
<ol type="1">
<li><p>4 amplitudes (<img src="https://latex.codecogs.com/png.latex?a,%20b,%20c,%20d">).</p></li>
<li><p>Minus 1 constraint for normalization (<img src="https://latex.codecogs.com/png.latex?a%5E2+b%5E2+c%5E2+d%5E2=1">).</p></li>
<li><p><strong>Total = 3.</strong></p></li>
</ol>
<p>Our current Ansatz only has <strong>2 parameters</strong> (<img src="https://latex.codecogs.com/png.latex?%5Ctheta_0,%20%5Ctheta_1">). We are trying to map a 2D surface onto a 3D space. There are vast regions of the Hilbert space we simply cannot reach. To fix this, we need a <strong>third parameter</strong>.</p>
<section id="introducing-the-controlled-ry" class="level3">
<h3 class="anchored" data-anchor-id="introducing-the-controlled-ry">Introducing the Controlled-RY</h3>
<p>Instead of a fixed <code>CNOT</code> (which has 0 parameters), we can conceptually use a parameterized <strong>Controlled-Rotation (<img src="https://latex.codecogs.com/png.latex?CR_Y">)</strong>.</p>
<p>This gate rotates the second qubit by an angle <img src="https://latex.codecogs.com/png.latex?%5Ctheta_2"> <em>only if</em> the first qubit is 1. This gives us independent control over the “top half” (<img src="https://latex.codecogs.com/png.latex?%7C00%5Crangle,%20%7C01%5Crangle">) and “bottom half” (<img src="https://latex.codecogs.com/png.latex?%7C10%5Crangle,%20%7C11%5Crangle">) of the vector, unlocking the 3rd degree of freedom.</p>
<div id="f6d936ff" class="cell" data-execution_count="5">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Define 3 Parameters</span></span>
<span id="cb9-2">theta_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ0'</span>)</span>
<span id="cb9-3">theta_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ1'</span>)</span>
<span id="cb9-4">theta_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ2'</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- The new parameter</span></span>
<span id="cb9-5"></span>
<span id="cb9-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Build the "Perfect" Ansatz (Conceptually)</span></span>
<span id="cb9-7">qc_perfect <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb9-8">qc_perfect.ry(theta_0, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb9-9">qc_perfect.ry(theta_1, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb9-10">qc_perfect.cry(theta_2, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- Parameterized Entanglement</span></span>
<span id="cb9-11"></span>
<span id="cb9-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Optimize with the new circuit</span></span>
<span id="cb9-13"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> cost_function_perfect(params):</span>
<span id="cb9-14">    pub <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (qc_perfect, hamiltonian_hard, params)</span>
<span id="cb9-15">    job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([pub])</span>
<span id="cb9-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>].data.evs)</span>
<span id="cb9-17"></span>
<span id="cb9-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We now pass 3 initial guesses</span></span>
<span id="cb9-19">result_perfect <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> minimize(cost_function_perfect, [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>], method<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'COBYLA'</span>)</span>
<span id="cb9-20"></span>
<span id="cb9-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Target Eigenvalue:       -1.0000"</span>)</span>
<span id="cb9-22"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Best Value Found (3-Param): </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>result_perfect<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>fun<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.4f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Target Eigenvalue:       -1.0000
Best Value Found (3-Param): -1.0000</code></pre>
</div>
</div>
<p><strong>Success!</strong> With 3 parameters matching the 3 degrees of freedom, the optimizer can now find the exact solution for <em>any</em> 4x4 real matrix.</p>
<blockquote class="blockquote">
<p><strong>Note:</strong> While <code>CRY</code> is mathematically perfect here, real hardware (like IBM’s) usually doesn’t have a native <code>CRY</code> gate. We would have to build it out of 2 CNOTs, which increases noise. This is the constant trade-off in Ansatz design: <strong>Expressibility vs.&nbsp;Hardware Cost.</strong></p>
</blockquote>
</section>
</section>
<section id="the-complications-why-we-cant-just-scale-up" class="level2">
<h2 class="anchored" data-anchor-id="the-complications-why-we-cant-just-scale-up">5. The Complications: Why We Can’t “Just Scale Up”</h2>
<p>In this example, adding one gate solved everything. It seems obvious: just add rotations and CNOTs everywhere, right? Not quite. This brings us to the theoretical wall of Variational Quantum Algorithms.</p>
<p>Let’s do the math on how many parameters we actually need as we scale up.</p>
<section id="the-real-symmetric-case-2-qubits-4-dimensions" class="level3">
<h3 class="anchored" data-anchor-id="the-real-symmetric-case-2-qubits-4-dimensions">The Real Symmetric Case (2 qubits, 4 dimensions)</h3>
<p>We just saw that for a <img src="https://latex.codecogs.com/png.latex?4%20%5Ctimes%204"> real symmetric matrix, we need <strong>3</strong> parameters.</p>
<ul>
<li><p>The vector has 4 real values: <img src="https://latex.codecogs.com/png.latex?a,%20b,%20c,%20d">.</p></li>
<li><p>There is 1 constraint (normalization): <img src="https://latex.codecogs.com/png.latex?a%5E2%20+%20b%5E2%20+%20c%5E2%20+%20d%5E2%20=%201">.</p></li>
<li><p><strong>Total parameters:</strong> <img src="https://latex.codecogs.com/png.latex?4%20-%201%20=%203">.</p></li>
</ul>
</section>
<section id="the-real-symmetric-case-n-qubits-2n-dimensions" class="level3">
<h3 class="anchored" data-anchor-id="the-real-symmetric-case-n-qubits-2n-dimensions">The Real Symmetric Case (N qubits, 2^N dimensions)</h3>
<p>If we scale this logic up to a system with <img src="https://latex.codecogs.com/png.latex?N"> qubits, the Hilbert space dimension is <img src="https://latex.codecogs.com/png.latex?D%20=%202%5EN">.</p>
<ul>
<li><p>The vector has <img src="https://latex.codecogs.com/png.latex?2%5EN"> real values.</p></li>
<li><p>Normalization removes 1 degree of freedom.</p></li>
<li><p><strong>Total parameters:</strong> <img src="https://latex.codecogs.com/png.latex?2%5EN%20-%201">.</p></li>
</ul>
</section>
<section id="the-general-quantum-case-complex-hermitian" class="level3">
<h3 class="anchored" data-anchor-id="the-general-quantum-case-complex-hermitian">The General Quantum Case (Complex Hermitian)</h3>
<p>However, quantum mechanics is not real; it is complex. For a general <img src="https://latex.codecogs.com/png.latex?N">-qubit system, the state vector consists of <img src="https://latex.codecogs.com/png.latex?2%5EN"> complex amplitudes (<img src="https://latex.codecogs.com/png.latex?a%20+%20bi">).</p>
<ul>
<li><p><strong>Raw Numbers:</strong> Each amplitude has 2 real components (real and imaginary parts). So we have <img src="https://latex.codecogs.com/png.latex?2%20%5Ctimes%202%5EN"> total real numbers.</p></li>
<li><p><strong>Constraint 1 (Normalization):</strong> The sum of probabilities must be 1. (Removes 1 parameter).</p></li>
<li><p><strong>Constraint 2 (Global Phase):</strong> In quantum mechanics, the states <img src="https://latex.codecogs.com/png.latex?%7C%5Cpsi%5Crangle"> and <img src="https://latex.codecogs.com/png.latex?e%5E%7Bi%5Cphi%7D%7C%5Cpsi%5Crangle"> are physically indistinguishable. We can freely choose the global phase. (Removes 1 parameter).</p></li>
</ul>
<p><strong>The Final Count:</strong> To fully define an arbitrary quantum state of <img src="https://latex.codecogs.com/png.latex?N"> qubits, the number of real parameters required is: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BParameters%7D%20=%202(2%5EN)%20-%202%0A"></p>
</section>
<section id="the-reality-check-n-50" class="level3">
<h3 class="anchored" data-anchor-id="the-reality-check-n-50">The Reality Check: N = 50</h3>
<p>Let’s look at the numbers for a useful quantum computer:</p>
<ul>
<li><p><strong>Dimension:</strong> <img src="https://latex.codecogs.com/png.latex?2%5E%7B50%7D%20%5Capprox%2010%5E%7B15%7D"> (1 Quadrillion states).</p></li>
<li><p><strong>Parameters Needed:</strong> <img src="https://latex.codecogs.com/png.latex?%5Capprox%202%20%5Ctimes%2010%5E%7B15%7D">.</p></li>
</ul>
<p>If we tried to build a “universal” circuit with 1 quadrillion parameters, two things would happen:</p>
<ol type="1">
<li><p><strong>The Quantum Wall:</strong> The circuit would be so deep that noise would destroy the state before we finished preparing it.</p></li>
<li><p><strong>The Classical Wall (Barren Plateaus):</strong> Even with a perfect quantum computer, a classical optimizer cannot handle <img src="https://latex.codecogs.com/png.latex?10%5E%7B15%7D"> variables. In such a high-dimensional space, the energy landscape becomes essentially flat. The gradient vanishes, and the optimizer gets stuck, having no idea which direction leads “down”.</p></li>
</ol>
</section>
</section>
<section id="the-solution-the-ansatz" class="level2">
<h2 class="anchored" data-anchor-id="the-solution-the-ansatz">6. The Solution: The Ansatz</h2>
<p>This is why we cannot simply “parameterize everything.” We must be selective. We cannot search the entire Hilbert space. We must choose a specific <strong>subspace</strong> where we suspect the answer lies.</p>
<p>We define a fixed circuit structure—called an <strong>Ansatz</strong> (German for “approach”)—that uses a manageable number of parameters (e.g., <img src="https://latex.codecogs.com/png.latex?N%5E2"> or even <img src="https://latex.codecogs.com/png.latex?N">).</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7Cv(%5Cvec%7B%5Ctheta%7D)%5Crangle%20=%20U_%7B%5Ctext%7BAnsatz%7D%7D(%5Cvec%7B%5Ctheta%7D)%20%7C0%5Cdots0%5Crangle%0A"></p>
<p>The “Art” of VQE is designing an Ansatz that is</p>
<ol type="1">
<li><p><strong>Expressive enough</strong> to capture the physics of the problem (as we saw with the CNOT).</p></li>
<li><p><strong>Simple enough</strong> to be optimized on real hardware.</p></li>
</ol>
<p>In the next post, we will compare different Ansatz strategies—specifically <strong>Hardware Efficient</strong> circuits vs.&nbsp;<strong>Chemically Inspired</strong> ones (like UCCSD)—to see how we balance accuracy with complexity.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>VQE</category>
  <category>Ansatz</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/05-art-of-the-ansatz.html</guid>
  <pubDate>Fri, 19 Dec 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>Closing the Loop: From Fixed Angles to Optimization</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/04-closing-the-loop.html</link>
  <description><![CDATA[ 





<p>In our <a href="../../posts/quantum_diagonalization/03-encoding-math-into-metal.html">last post</a>, we successfully calculated the value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v"> for a <em>specific</em> vector <img src="https://latex.codecogs.com/png.latex?v">. We manually rotated our qubits by specific angles (<img src="https://latex.codecogs.com/png.latex?%5Cpi/3"> and <img src="https://latex.codecogs.com/png.latex?%5Cpi/4">), ran the Estimator, and verified that the result matched our classical calculation.</p>
<p>But in a real problem, we don’t know the answer ahead of time. We don’t know the specific angles that create the solution. We are searching for the <strong>minimum eigenvalue</strong> (<img src="https://latex.codecogs.com/png.latex?%5Clambda_0">) and its corresponding <strong>eigenvector</strong> (<img src="https://latex.codecogs.com/png.latex?x_0">).</p>
<p>To find them, we must transition from a static calculation to a dynamic <strong>optimization loop</strong>.</p>
<section id="the-hybrid-loop" class="level2">
<h2 class="anchored" data-anchor-id="the-hybrid-loop">1. The Hybrid Loop</h2>
<p>The quantum computer cannot “find” the minimum on its own. It is just a very expensive function evaluator. It takes a set of angles <img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctheta%7D"> and returns a cost <img src="https://latex.codecogs.com/png.latex?E">. The logic for <em>how</em> to change <img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctheta%7D"> to lower the cost lives on the classical computer.</p>
<p>This creates a hybrid feedback loop:</p>
<ol type="1">
<li><strong>Classical CPU:</strong> Guesses a set of parameters <img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctheta%7D"> (e.g., <img src="https://latex.codecogs.com/png.latex?%5B0,%200%5D">).</li>
<li><strong>Quantum QPU (Estimator):</strong> Prepares the state <img src="https://latex.codecogs.com/png.latex?%7Cv(%5Cvec%7B%5Ctheta%7D)%5Crangle"> and measures the expectation value <img src="https://latex.codecogs.com/png.latex?E%20=%20%5Clangle%20v(%5Cvec%7B%5Ctheta%7D)%20%7C%20A%20%7C%20v(%5Cvec%7B%5Ctheta%7D)%20%5Crangle">.</li>
<li><strong>Classical CPU:</strong> Looks at <img src="https://latex.codecogs.com/png.latex?E">. Is it lower than before?
<ul>
<li><em>Yes:</em> Move further in that direction.</li>
<li><em>No:</em> Try a different direction.</li>
</ul></li>
<li><strong>Repeat</strong> until the value converges to the minimum.</li>
</ol>
</section>
<section id="step-a-finding-the-minimum-eigenvalue" class="level2">
<h2 class="anchored" data-anchor-id="step-a-finding-the-minimum-eigenvalue">2. Step A: Finding the Minimum Eigenvalue</h2>
<p>Let’s make this concrete. We will use the <strong>exact same matrix</strong> from the previous post, but we will upgrade our circuit. Last time, we hard-coded <code>np.pi/3</code>. This time, we will insert a symbolic <strong>Parameter</strong> and let the optimizer find that value for us.</p>
<p><strong>The Matrix (<img src="https://latex.codecogs.com/png.latex?A">):</strong> <img src="https://latex.codecogs.com/png.latex?A%20=%200.5%20(Z%20%5Cotimes%20Z)%20+%200.2%20(X%20%5Cotimes%20X)"></p>
<div id="6b81da2e" class="cell" data-execution_count="1">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.circuit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Parameter</span>
<span id="cb1-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.quantum_info <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SparsePauliOp</span>
<span id="cb1-5"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorEstimator</span>
<span id="cb1-6"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> scipy.optimize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> minimize</span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Define the Hamiltonian</span></span>
<span id="cb1-9">hamiltonian <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SparsePauliOp.from_list([(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ZZ"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>), (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"XX"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>)])</span>
<span id="cb1-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Target Hamiltonian: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>hamiltonian<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Target Hamiltonian: SparsePauliOp(['ZZ', 'XX'],
              coeffs=[0.5+0.j, 0.2+0.j])</code></pre>
</div>
</div>
<section id="parameterizing-the-circuit" class="level3">
<h3 class="anchored" data-anchor-id="parameterizing-the-circuit">Parameterizing the Circuit</h3>
<p>In Qiskit, we use <code>Parameter</code> objects to create algebraic variables. These are the “knobs” our classical optimizer will turn.</p>
<div id="7329e61c" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Define the Parameters</span></span>
<span id="cb3-2">theta_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ0'</span>)</span>
<span id="cb3-3">theta_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Parameter(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'θ1'</span>)</span>
<span id="cb3-4"></span>
<span id="cb3-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Build the Circuit</span></span>
<span id="cb3-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Instead of fixed angles, we use the parameters.</span></span>
<span id="cb3-7">qc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb3-8">qc.ry(theta_0, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) </span>
<span id="cb3-9">qc.ry(theta_1, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Parameterized Circuit:"</span>)</span>
<span id="cb3-12">display(qc.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mpl"</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Parameterized Circuit:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/04-closing-the-loop_files/figure-html/cell-3-output-2.png" width="170" height="168" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="the-cost-function" class="level3">
<h3 class="anchored" data-anchor-id="the-cost-function">The Cost Function</h3>
<p>We need a standard Python function that the optimizer can call. This function takes a list of numbers (the current values of <img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctheta%7D">) and returns a single number (the eigenvalue estimate).</p>
<div id="d1056ea7" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">estimator <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorEstimator()</span>
<span id="cb5-2"></span>
<span id="cb5-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> cost_function(params):</span>
<span id="cb5-4">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb5-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">    Input: params = [val_0, val_1]</span></span>
<span id="cb5-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">    Output: Expectation Value &lt;v(params)|A|v(params)&gt;</span></span>
<span id="cb5-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">    """</span></span>
<span id="cb5-8">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Bind the numerical values to the circuit parameters</span></span>
<span id="cb5-9">    pub <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (qc, hamiltonian, params)</span>
<span id="cb5-10">    </span>
<span id="cb5-11">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Run the job</span></span>
<span id="cb5-12">    job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([pub])</span>
<span id="cb5-13">    result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb5-14">    </span>
<span id="cb5-15">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Return the scalar float</span></span>
<span id="cb5-16">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We explicitly cast to float to avoid numpy array issues in scipy</span></span>
<span id="cb5-17">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">float</span>(result.data.evs)</span>
<span id="cb5-18"></span>
<span id="cb5-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Test it with a random guess to make sure it works</span></span>
<span id="cb5-20">test_guess <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>]</span>
<span id="cb5-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Value at [0,0]: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>cost_function(test_guess)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.4f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Value at [0,0]: 0.5000</code></pre>
</div>
</div>
</section>
<section id="running-the-optimization" class="level3">
<h3 class="anchored" data-anchor-id="running-the-optimization">Running the Optimization</h3>
<p>We use <code>scipy.optimize.minimize</code> with the <strong>COBYLA</strong> method. This is a “gradient-free” optimizer, often used in quantum computing because it handles noise better than standard gradient descent.</p>
<div id="c6b10330" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Initial Guess</span></span>
<span id="cb7-2">initial_guess <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>]</span>
<span id="cb7-3"></span>
<span id="cb7-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Starting Optimization..."</span>)</span>
<span id="cb7-5"></span>
<span id="cb7-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. The Minimization Routine</span></span>
<span id="cb7-7">result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> minimize(cost_function, initial_guess, method<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'COBYLA'</span>)</span>
<span id="cb7-8"></span>
<span id="cb7-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. The Output</span></span>
<span id="cb7-10">optimal_angles <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result.x</span>
<span id="cb7-11">min_eigenvalue <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result.fun</span>
<span id="cb7-12"></span>
<span id="cb7-13"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">Optimization Complete!"</span>)</span>
<span id="cb7-14"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Optimal Angles found: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>optimal_angles<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb7-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Minimum Eigenvalue found: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>min_eigenvalue<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Starting Optimization...

Optimization Complete!
Optimal Angles found: [3.14157719e+00 8.62918814e-05]
Minimum Eigenvalue found: -0.500000</code></pre>
</div>
</div>
<p>Success! The optimizer automatically found the angles that produce the minimum eigenvalue.</p>
</section>
</section>
<section id="step-b-retrieving-the-eigenvector" class="level2">
<h2 class="anchored" data-anchor-id="step-b-retrieving-the-eigenvector">3. Step B: Retrieving the Eigenvector</h2>
<p>We have found the minimum eigenvalue (<img src="https://latex.codecogs.com/png.latex?%5Clambda_0">), but in many applications (like data science or chemistry), we also need the <strong>eigenvector</strong> itself (<img src="https://latex.codecogs.com/png.latex?x_0">).</p>
<p>The <strong>Estimator</strong> only gives us the energy. To see the vector structure, we use the <strong>Sampler</strong>. The Sampler gives us the probability (<img src="https://latex.codecogs.com/png.latex?P">) of measuring each state. Since <img src="https://latex.codecogs.com/png.latex?P%20=%20%7C%5Cpsi%7C%5E2">, we can reconstruct the magnitude of the state vector.</p>
<p><em>Note: The Sampler recovers the magnitude, but not the relative phases (signs). For that, we would need more complex tomography. For now, we compare the probability distributions.</em></p>
<div id="751ff8e0" class="cell" data-execution_count="5">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorSampler</span>
<span id="cb9-2"></span>
<span id="cb9-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Prepare the Circuit for Sampling</span></span>
<span id="cb9-4">qc_sampled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> qc.copy()</span>
<span id="cb9-5">qc_sampled.measure_all()</span>
<span id="cb9-6"></span>
<span id="cb9-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Run the Sampler using the OPTIMAL angles</span></span>
<span id="cb9-8">sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorSampler()</span>
<span id="cb9-9">job_sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sampler.run([(qc_sampled, optimal_angles)])</span>
<span id="cb9-10">result_sampler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job_sampler.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb9-11"></span>
<span id="cb9-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Reconstruct the Vector</span></span>
<span id="cb9-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Get counts and convert to probabilities</span></span>
<span id="cb9-14">counts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result_sampler.data.meas.get_counts()</span>
<span id="cb9-15">total_shots <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(counts.values())</span>
<span id="cb9-16"></span>
<span id="cb9-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We strictly order the states: |00&gt;, |01&gt;, |10&gt;, |11&gt;</span></span>
<span id="cb9-18">states <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'00'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'01'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'10'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'11'</span>]</span>
<span id="cb9-19"></span>
<span id="cb9-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate Probabilities</span></span>
<span id="cb9-21">probs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([counts.get(s, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> total_shots <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> s <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> states])</span>
<span id="cb9-22"></span>
<span id="cb9-23"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate Amplitudes (Sqrt of probability)</span></span>
<span id="cb9-24">quantum_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.sqrt(probs)</span>
<span id="cb9-25"></span>
<span id="cb9-26"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Reconstructed Quantum Eigenvector:"</span>)</span>
<span id="cb9-27"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(quantum_vector)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Reconstructed Quantum Eigenvector:
[0. 1. 0. 0.]</code></pre>
</div>
</div>
</section>
<section id="the-reality-check-did-we-fail" class="level2">
<h2 class="anchored" data-anchor-id="the-reality-check-did-we-fail">4. The Reality Check: Did we fail?</h2>
<p>We have an answer. The optimization loop converged successfully. But is it the <em>correct</em> answer?</p>
<p>Let’s verify this using standard linear algebra tools like <code>numpy</code>. We will construct the matrix <img src="https://latex.codecogs.com/png.latex?A"> explicitly, diagonalize it, and find the true eigenvector.</p>
<div id="2ead9564" class="cell" data-execution_count="6">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Construct the Matrix A Classically</span></span>
<span id="cb11-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># A = 0.5*ZZ + 0.2*XX</span></span>
<span id="cb11-3">matrix_A <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.array([</span>
<span id="cb11-4">    [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>],</span>
<span id="cb11-5">    [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,  <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>  ],</span>
<span id="cb11-6">    [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>,<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>  ],</span>
<span id="cb11-7">    [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>,   <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>]</span>
<span id="cb11-8">])</span>
<span id="cb11-9"></span>
<span id="cb11-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. Calculate Eigenvalues and Eigenvectors</span></span>
<span id="cb11-11">eigenvals, eigenvecs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.linalg.eigh(matrix_A)</span>
<span id="cb11-12"></span>
<span id="cb11-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. Extract the Minimum</span></span>
<span id="cb11-14">true_eigenvalue <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> eigenvals[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb11-15">true_eigenvector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> eigenvecs[:, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb11-16"></span>
<span id="cb11-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4. Take absolute value for comparison (ignoring phase signs)</span></span>
<span id="cb11-18">true_vector_abs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">abs</span>(true_eigenvector)</span>
<span id="cb11-19"></span>
<span id="cb11-20"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"True Minimum Eigenvalue: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>true_eigenvalue<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb11-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"True Eigenvector (Abs):  </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>true_vector_abs<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb11-22"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"-"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>)</span>
<span id="cb11-23"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Quantum Value Found:     </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>min_eigenvalue<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb11-24"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Quantum Vector Distance: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>np<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>linalg<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>norm(quantum_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> true_vector_abs)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>True Minimum Eigenvalue: -0.700000
True Eigenvector (Abs):  [0.         0.70710678 0.70710678 0.        ]
------------------------------
Quantum Value Found:     -0.500000
Quantum Vector Distance: 0.765367</code></pre>
</div>
</div>
<section id="the-discrepancy" class="level3">
<h3 class="anchored" data-anchor-id="the-discrepancy">The Discrepancy</h3>
<p>Look at the results above. 1. <strong>The Value:</strong> The quantum result is significantly higher than the true minimum. 2. <strong>The Vector:</strong> The distance is large (likely <img src="https://latex.codecogs.com/png.latex?%3E0.7">).</p>
<p>The code worked perfectly. The optimizer did its job. Yet, we failed to find the ground state. <strong>Why?</strong></p>
<p>The answer lies in the <strong>Ansatz</strong> (the circuit structure). We constructed our circuit using only independent rotations (<code>RY</code> on qubit 0, <code>RY</code> on qubit 1).</p>
<p><img src="https://latex.codecogs.com/png.latex?%7C%5Cpsi%5Crangle%20=%20(a%7C0%5Crangle%20+%20b%7C1%5Crangle)%20%5Cotimes%20(c%7C0%5Crangle%20+%20d%7C1%5Crangle)"></p>
<p>The classical calculation reveals that the true ground state is a <strong>Bell State</strong> approximation—a <strong>maximally entangled</strong> state where the qubits are correlated.</p>
<p>Mathematically, a tensor product of single qubits (which is all our current circuit can produce) can <strong>never</strong> create an entangled state. We tried to fit a round peg (an entangled ground state) into a square hole (a product-state circuit).</p>
<p>No matter how long we run the optimizer, we will never reach the true minimum because it physically does not exist in the search space of our current circuit.</p>
<p><strong>Next Steps:</strong> We have the Engine (VQE loop), but we need better Fuel. In the next post, we will break the “Product State Barrier” by introducing <strong>Entanglement</strong> and designing a <strong>Hardware Efficient Ansatz</strong>.</p>


</section>
</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>VQE</category>
  <category>Optimization</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/04-closing-the-loop.html</guid>
  <pubDate>Fri, 12 Dec 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>Encoding Math into Metal: Representing Vectors and Matrices on a QPU</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal.html</link>
  <description><![CDATA[ 





<p>In my <a href="../../posts/quantum_diagonalization/02-variational-principle.html">previous post</a>, we established the mathematical goal of VQE: finding a normalized vector <img src="https://latex.codecogs.com/png.latex?v"> that minimizes the expectation value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>Mathematically, this is elegant. Computationally, it poses a massive storage problem. If our system has <img src="https://latex.codecogs.com/png.latex?N"> states, <img src="https://latex.codecogs.com/png.latex?v"> is a vector of size <img src="https://latex.codecogs.com/png.latex?N">, and <img src="https://latex.codecogs.com/png.latex?A"> is a matrix of size <img src="https://latex.codecogs.com/png.latex?N%20%5Ctimes%20N">. As we scale up, storing these explicitly becomes impossible.</p>
<p>To solve this on a quantum computer, we need to translate our classical data structures into quantum mechanics. We need to answer two fundamental questions:</p>
<ol type="1">
<li>How do we represent a high-dimensional vector <img src="https://latex.codecogs.com/png.latex?v"> on a quantum processor?</li>
<li>How do we represent the matrix <img src="https://latex.codecogs.com/png.latex?A"> so we can calculate its expectation value?</li>
</ol>
<section id="representing-an-n-dimensional-vector" class="level2">
<h2 class="anchored" data-anchor-id="representing-an-n-dimensional-vector">1. Representing an N-dimensional Vector</h2>
<p>In the classical world, if I want to store a state vector <img src="https://latex.codecogs.com/png.latex?v"> of size <img src="https://latex.codecogs.com/png.latex?N=4">, I allocate an array of 4 floating-point numbers in memory:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0Av_%7Bclassical%7D%20=%20%5Cbegin%7Bbmatrix%7D%20v_0%20%5C%5C%20v_1%20%5C%5C%20v_2%20%5C%5C%20v_3%20%5Cend%7Bbmatrix%7D%0A"></p>
<p>The memory requirement grows linearly with <img src="https://latex.codecogs.com/png.latex?N">. However, in quantum problems, <img src="https://latex.codecogs.com/png.latex?N"> represents the dimension of the Hilbert space, which grows <strong>exponentially</strong> with the number of particles or qubits (<img src="https://latex.codecogs.com/png.latex?N%20=%202%5En">).</p>
<section id="the-quantum-compression" class="level3">
<h3 class="anchored" data-anchor-id="the-quantum-compression">The Quantum Compression</h3>
<p>On a quantum computer, we use <strong>Amplitude Encoding</strong>. We map the <strong>indices</strong> of the vector to the <strong>computational basis states</strong> of our qubits.</p>
<p>To represent a vector of size <img src="https://latex.codecogs.com/png.latex?N">, we need only <img src="https://latex.codecogs.com/png.latex?n%20=%20%5Clog_2(N)"> qubits. For our <img src="https://latex.codecogs.com/png.latex?N=4"> example, we need just <img src="https://latex.codecogs.com/png.latex?n=2"> qubits. The indices <img src="https://latex.codecogs.com/png.latex?0,%201,%202,%203"> correspond to the binary states <img src="https://latex.codecogs.com/png.latex?%7C00%5Crangle,%20%7C01%5Crangle,%20%7C10%5Crangle,%20%7C11%5Crangle">.</p>
<p>The vector <img src="https://latex.codecogs.com/png.latex?v"> is then represented as the <strong>superposition state</strong> of the quantum system:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%7Cv%5Crangle%20=%20v_0%7C00%5Crangle%20+%20v_1%7C01%5Crangle%20+%20v_2%7C10%5Crangle%20+%20v_3%7C11%5Crangle%0A"></p>
</section>
<section id="the-constraint-normalization" class="level3">
<h3 class="anchored" data-anchor-id="the-constraint-normalization">The Constraint: Normalization</h3>
<p>There is one strict constraint. In classical coding, a vector can have any magnitude. In quantum mechanics, probabilities must sum to 1. Therefore, the vector <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> must be normalized such that the sum of the squared absolute values of its coefficients equals 1:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bi=0%7D%5E%7BN-1%7D%20%7Cv_i%7C%5E2%20=%201%0A"></p>
<p>This means that our quantum state <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> is mathematically identical to the normalized vector <img src="https://latex.codecogs.com/png.latex?v"> we discussed in the previous post. We aren’t “storing” the numbers <img src="https://latex.codecogs.com/png.latex?v_i"> in digital memory addresses; the numbers <img src="https://latex.codecogs.com/png.latex?v_i"> exist physically as the probability amplitudes of the wavefunction itself.</p>
</section>
</section>
<section id="representing-the-nxn-matrix" class="level2">
<h2 class="anchored" data-anchor-id="representing-the-nxn-matrix">2. Representing the NxN Matrix</h2>
<p>Now, what about the matrix <img src="https://latex.codecogs.com/png.latex?A">? Classically, <img src="https://latex.codecogs.com/png.latex?A"> is a dense grid of numbers. If the vector has dimension <img src="https://latex.codecogs.com/png.latex?N=2%5En">, the matrix has <img src="https://latex.codecogs.com/png.latex?(2%5En)%5E2"> entries. Storing a matrix for just 50 qubits would require more memory than exists on Earth.</p>
<p>In the quantum context, <img src="https://latex.codecogs.com/png.latex?A"> represents an observable (usually a Hamiltonian). We do not store this matrix in the quantum computer’s memory. Instead, we represent it in the native language of the quantum processor: <strong>Pauli Strings</strong>.</p>
<section id="the-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="the-decomposition">The Decomposition</h3>
<p>The set of Pauli matrices <img src="https://latex.codecogs.com/png.latex?%5C%7BI,%20X,%20Y,%20Z%5C%7D"> forms a complete basis for the space of <img src="https://latex.codecogs.com/png.latex?2%20%5Ctimes%202"> Hermitian matrices. For a multi-qubit system, we use tensor products of these matrices (e.g., <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z"> or <img src="https://latex.codecogs.com/png.latex?X%20%5Cotimes%20I">).</p>
<p>Any Hermitian matrix <img src="https://latex.codecogs.com/png.latex?A"> can be written as a weighted sum of these Pauli strings:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AA%20=%20%5Csum_%7Bj%7D%20c_j%20P_j%0A"></p>
<p>Where <img src="https://latex.codecogs.com/png.latex?c_j"> are real-valued scalar coefficients and <img src="https://latex.codecogs.com/png.latex?P_j"> are Pauli strings.</p>
</section>
<section id="a-crucial-detail-where-do-these-strings-come-from" class="level3">
<h3 class="anchored" data-anchor-id="a-crucial-detail-where-do-these-strings-come-from">A Crucial Detail: Where do these strings come from?</h3>
<p>You might be asking: <em>“If the matrix <img src="https://latex.codecogs.com/png.latex?A"> is too big to store, how do we calculate this decomposition?”</em></p>
<p>There are two scenarios:</p>
<ol type="1">
<li><p><strong>The Mathematical Route:</strong> If we <em>did</em> have a small arbitrary matrix, we could mathematically decompose it using the <strong>Hilbert-Schmidt inner product</strong>. We project the matrix onto each Pauli basis tensor to find the coefficients <img src="https://latex.codecogs.com/png.latex?c_j">. However, doing this for large <img src="https://latex.codecogs.com/png.latex?N"> defeats the purpose, as we would need to build the giant matrix first.</p></li>
<li><p><strong>The Practical Route (Direct Mapping):</strong> In useful quantum applications (like Chemistry or Optimization), <strong>we never build the dense matrix</strong>.</p>
<ul>
<li><strong>In Chemistry:</strong> The interaction between electrons is described by the <strong>Jordan-Wigner</strong> or <strong>Bravyi-Kitaev</strong> transformations, which map the physical system <em>directly</em> into a sum of Pauli strings (<img src="https://latex.codecogs.com/png.latex?O(n%5E4)"> terms) without ever creating a <img src="https://latex.codecogs.com/png.latex?2%5En%20%5Ctimes%202%5En"> array.</li>
<li><strong>In Optimization (MaxCut):</strong> The cost function of a graph cut maps directly to a sum of <img src="https://latex.codecogs.com/png.latex?Z_i%20Z_j"> terms based on the graph’s edges.</li>
</ul></li>
</ol>
<p>This allows us to work with operators for 50+ qubits (a vector space of <img src="https://latex.codecogs.com/png.latex?10%5E%7B15%7D">) while only storing a polynomial number of Pauli terms in our laptop’s memory.</p>
<blockquote class="blockquote">
<p><strong>Note:</strong> If these transformations sound complex, don’t worry. We will dedicate a future post in this series specifically to <strong>Problem Mapping</strong>—showing exactly how to turn a physical chemistry problem or a logistics graph into these Pauli strings without ever building the giant matrix.</p>
</blockquote>
</section>
<section id="why-this-solves-the-complexity-problem" class="level3">
<h3 class="anchored" data-anchor-id="why-this-solves-the-complexity-problem">Why This Solves the Complexity Problem</h3>
<p>This representation changes the problem from “massive matrix multiplication” to “linear summation.”</p>
<p>Recall that we want to calculate the expectation value <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle">. Using the linearity of expectation, we can break this down:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle%20=%20%5Clangle%20v%20%7C%20%5Cleft(%20%5Csum_j%20c_j%20P_j%20%5Cright)%20%7C%20v%20%5Crangle%20=%20%5Csum_j%20c_j%20%5Clangle%20v%20%7C%20P_j%20%7C%20v%20%5Crangle%0A"></p>
<p>This is the key to the efficiency of the algorithm. We don’t need a quantum computer that can “process” the giant matrix <img src="https://latex.codecogs.com/png.latex?A"> all at once. We only need a quantum computer that can measure simple Pauli terms.</p>
</section>
</section>
<section id="calculating-the-expectation-value" class="level2">
<h2 class="anchored" data-anchor-id="calculating-the-expectation-value">3. Calculating the Expectation Value</h2>
<p>We have defined our vector <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> and decomposed our matrix <img src="https://latex.codecogs.com/png.latex?A">. Now comes the actual computation: calculating <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20P_j%20%7C%20v%20%5Crangle">. How do we actually ask a quantum computer for this number?</p>
<section id="a-the-manual-approach-sampling-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="a-the-manual-approach-sampling-eigenvalues">A) The Manual Approach: Sampling Eigenvalues</h3>
<p>Let’s assume our Hamiltonian is just a single Pauli string, say <img src="https://latex.codecogs.com/png.latex?Z"> on a single qubit. The expectation value is simply the weighted average of outcomes. We run the circuit, measure the qubit, and collect the bitstrings (e.g., <code>0</code>, <code>0</code>, <code>1</code>, <code>0</code>…). mapping <code>0</code> to <img src="https://latex.codecogs.com/png.latex?+1"> and <code>1</code> to <img src="https://latex.codecogs.com/png.latex?-1">.</p>
<p><strong>Why this mapping?</strong> This isn’t arbitrary. It relies on the known spectral properties of Pauli matrices. The computational basis states <img src="https://latex.codecogs.com/png.latex?%7C0%5Crangle"> and <img src="https://latex.codecogs.com/png.latex?%7C1%5Crangle"> are the <strong>eigenstates</strong> of the Pauli <img src="https://latex.codecogs.com/png.latex?Z"> operator, with eigenvalues <img src="https://latex.codecogs.com/png.latex?+1"> and <img src="https://latex.codecogs.com/png.latex?-1"> respectively:</p>
<p><img src="https://latex.codecogs.com/png.latex?Z%7C0%5Crangle%20=%20(+1)%7C0%5Crangle"> <img src="https://latex.codecogs.com/png.latex?Z%7C1%5Crangle%20=%20(-1)%7C1%5Crangle"></p>
<p>When we measure a qubit, we are collapsing it into one of these eigenstates. The value we associate with that outcome is the corresponding eigenvalue.</p>
<p><strong>Extending to Multi-Qubit Terms</strong> Crucially, the eigenvalue of a tensor product of Pauli matrices is simply the <strong>product</strong> of the eigenvalues of each individual matrix.</p>
<p>For example, if we are measuring the operator <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z"> on two qubits and we observe the state <img src="https://latex.codecogs.com/png.latex?%7C01%5Crangle">: * The first qubit is in <img src="https://latex.codecogs.com/png.latex?%7C0%5Crangle"> (eigenvalue <img src="https://latex.codecogs.com/png.latex?+1">). * The second qubit is in <img src="https://latex.codecogs.com/png.latex?%7C1%5Crangle"> (eigenvalue <img src="https://latex.codecogs.com/png.latex?-1">). * The total eigenvalue for this shot is <img src="https://latex.codecogs.com/png.latex?(+1)%20%5Ctimes%20(-1)%20=%20-1">.</p>
<p>This allows us to reconstruct the value of any complex Pauli string simply by multiplying the results of individual qubit measurements.</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Clangle%20Z%20%5Crangle%20%5Capprox%20%5Cfrac%7B(+1)%20%5Ccdot%20N_0%20+%20(-1)%20%5Ccdot%20N_1%7D%7BN_%7Btotal%7D%7D"></p>
<p><strong>What about X and Y?</strong> Quantum hardware generally only measures in the <strong>Z-basis</strong>. If our Pauli string contains an <img src="https://latex.codecogs.com/png.latex?X"> or <img src="https://latex.codecogs.com/png.latex?Y">, we cannot measure it directly. We must apply a basis rotation gate (like a Hadamard for <img src="https://latex.codecogs.com/png.latex?X">) <em>just before</em> measurement to align the axis with <img src="https://latex.codecogs.com/png.latex?Z">.</p>
</section>
<section id="b-the-challenge-the-explosion-of-terms" class="level3">
<h3 class="anchored" data-anchor-id="b-the-challenge-the-explosion-of-terms">B) The Challenge: The Explosion of Terms</h3>
<p>In a real problem, our matrix <img src="https://latex.codecogs.com/png.latex?A"> might contain <strong>thousands</strong> of Pauli terms.</p>
<p><img src="https://latex.codecogs.com/png.latex?H%20=%20c_1%20(Z_0%20Z_1)%20+%20c_2%20(X_0%20X_1)%20+%20c_3%20(Z_0%20I_1)%20+%20%5Cdots"></p>
<p>If we were to run a separate quantum experiment (Sampler job) for every single term, the overhead would be astronomical.</p>
<p><strong>The Solution: Operator Grouping</strong> Fortunately, we can exploit <strong>commutativity</strong>. If two Pauli strings commute (specifically, qubit-wise commutativity), they can be measured in the same basis simultaneously.</p>
<p>For example, <img src="https://latex.codecogs.com/png.latex?Z_0%20Z_1"> and <img src="https://latex.codecogs.com/png.latex?Z_0%20I_1"> both require the Z-basis. We can measure both in a single “shot”. However, <img src="https://latex.codecogs.com/png.latex?Z_0%20Z_1"> and <img src="https://latex.codecogs.com/png.latex?X_0%20X_1"> do <strong>not</strong> commute (Heisenberg’s Uncertainty Principle). You cannot measure Z and X on qubit 0 at the same time.</p>
<p>Therefore, we group the thousands of Pauli strings into a small number of <strong>commuting families</strong>. We run one quantum job per family, effectively compressing thousands of measurements into a few dozen jobs.</p>
</section>
<section id="c-the-abstraction-the-qiskit-estimator" class="level3">
<h3 class="anchored" data-anchor-id="c-the-abstraction-the-qiskit-estimator">C) The Abstraction: The Qiskit Estimator</h3>
<p>Doing this efficiently involves significant bookkeeping: checking commutativity, grouping terms, appending rotations, and aggregating statistics.</p>
<p>In modern Qiskit, this is abstracted away by the <strong>Estimator</strong>. The Estimator is a primitive that takes the Circuit (state) and the Operator (matrix), handles the grouping and rotations internally, and returns the final floating-point expectation value.</p>
</section>
</section>
<section id="code-example-the-estimator-in-action" class="level2">
<h2 class="anchored" data-anchor-id="code-example-the-estimator-in-action">4. Code Example: The Estimator in Action</h2>
<p>Let’s make this concrete. We will not start with quantum gates; we will start with a standard linear algebra problem.</p>
<p><strong>The Classical Problem</strong> Imagine we have a <img src="https://latex.codecogs.com/png.latex?4%20%5Ctimes%204"> Hermitian matrix <img src="https://latex.codecogs.com/png.latex?A"> and a 4-dimensional vector <img src="https://latex.codecogs.com/png.latex?v">, and we want to calculate <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AA%20=%20%5Cbegin%7Bbmatrix%7D%0A0.5%20&amp;%200%20&amp;%200%20&amp;%200.2%20%5C%5C%0A0%20&amp;%20-0.5%20&amp;%200.2%20&amp;%200%20%5C%5C%0A0%20&amp;%200.2%20&amp;%20-0.5%20&amp;%200%20%5C%5C%0A0.2%20&amp;%200%20&amp;%200%20&amp;%200.5%0A%5Cend%7Bbmatrix%7D%0A"></p>
<p>We want to verify the expectation value for a specific normalized vector: <img src="https://latex.codecogs.com/png.latex?%0Av%20%5Capprox%20%5Cbegin%7Bbmatrix%7D%200.80%20%5C%5C%200.46%20%5C%5C%200.33%20%5C%5C%200.19%20%5Cend%7Bbmatrix%7D%0A"></p>
<p>This problem is so small that one could do this on paper to determine that <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Capprox%200.299">. However, we are going to use this example to illustrate how this problem can be mapped to a quantum system and how it produces an output.</p>
<p><strong>1. The Matrix Decomposition:</strong> We cannot load the <img src="https://latex.codecogs.com/png.latex?4%20%5Ctimes%204"> array into the QPU. We must break it down. Looking at the structure of <img src="https://latex.codecogs.com/png.latex?A">: * The diagonal terms correspond to <img src="https://latex.codecogs.com/png.latex?Z%20%5Cotimes%20Z">. * The off-diagonal terms correspond to <img src="https://latex.codecogs.com/png.latex?X%20%5Cotimes%20X">.</p>
<p>We can rewrite <img src="https://latex.codecogs.com/png.latex?A"> exactly as: <img src="https://latex.codecogs.com/png.latex?A%20=%200.5%20(Z%20%5Cotimes%20Z)%20+%200.2%20(X%20%5Cotimes%20X)"></p>
<p><strong>2. The Vector Construction:</strong> Quantum computers always start in the <img src="https://latex.codecogs.com/png.latex?%7C00%5Crangle"> state (the vector <img src="https://latex.codecogs.com/png.latex?%5B1,%200,%200,%200%5D">). We need to build a circuit to transform this into our target vector <img src="https://latex.codecogs.com/png.latex?v">. We can do this using <img src="https://latex.codecogs.com/png.latex?R_Y"> (Rotation-Y) gates.</p>
<ul>
<li>Applying <img src="https://latex.codecogs.com/png.latex?R_Y(%5Cpi/3)"> to qubit 0 creates amplitudes <img src="https://latex.codecogs.com/png.latex?%5Capprox%20%5B0.866,%200.5%5D">.</li>
<li>Applying <img src="https://latex.codecogs.com/png.latex?R_Y(%5Cpi/4)"> to qubit 1 creates amplitudes <img src="https://latex.codecogs.com/png.latex?%5Capprox%20%5B0.924,%200.383%5D">.</li>
</ul>
<p>The tensor product of these rotations results in exactly our target vector <img src="https://latex.codecogs.com/png.latex?%5B0.80,%200.46,%200.33,%200.19%5D">.</p>
<section id="the-quantum-code" class="level3">
<h3 class="anchored" data-anchor-id="the-quantum-code">The Quantum Code</h3>
<p>Now, let’s write the code to implement this mapping and verify the result matches our classical calculation.</p>
<div id="8d534ba2" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit</span>
<span id="cb1-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.quantum_info <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SparsePauliOp</span>
<span id="cb1-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit.primitives <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> StatevectorEstimator</span>
<span id="cb1-5"></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. The Matrix A (The Hamiltonian)</span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We define A = 0.5 * (Z on q0, Z on q1) + 0.2 * (X on q0, X on q1)</span></span>
<span id="cb1-8">hamiltonian <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SparsePauliOp.from_list([</span>
<span id="cb1-9">    (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ZZ"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>),  </span>
<span id="cb1-10">    (<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"XX"</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>)   </span>
<span id="cb1-11">])</span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Operator A:"</span>, end<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">" "</span>)</span>
<span id="cb1-14">print_hamiltonian(hamiltonian)</span>
<span id="cb1-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Operator A: 0.50 * ZZ + 0.20 * XX

</code></pre>
</div>
</div>
<div id="629de96b" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. The Vector |v&gt; (State Preparation)</span></span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We use Ry gates to rotate the qubits from |0&gt; to a superposition.</span></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># using real-valued rotations keeps the amplitudes real.</span></span>
<span id="cb3-4">qc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb3-5">qc.ry(np.pi<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rotate qubit 0 by 60 degrees</span></span>
<span id="cb3-6">qc.ry(np.pi<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Rotate qubit 1 by 45 degrees</span></span>
<span id="cb3-7"></span>
<span id="cb3-8"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Circuit representing state |v&gt;:"</span>)</span>
<span id="cb3-9">display(qc.draw(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"mpl"</span>))</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Circuit representing state |v&gt;:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal_files/figure-html/cell-4-output-2.png" width="170" height="168" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="876f9e03" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. The Abstraction (The Estimator)</span></span>
<span id="cb5-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We instantiate the local StatevectorEstimator</span></span>
<span id="cb5-3">estimator <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> StatevectorEstimator()</span>
<span id="cb5-4"></span>
<span id="cb5-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># The estimator handles the basis rotations and operator grouping internally.</span></span>
<span id="cb5-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Run format: run([(circuit, operator)])</span></span>
<span id="cb5-7">job <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> estimator.run([(qc, hamiltonian)])</span>
<span id="cb5-8">result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> job.result()[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb5-9"></span>
<span id="cb5-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4. The Result</span></span>
<span id="cb5-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># result.data.evs is a NumPy array of expectation values.</span></span>
<span id="cb5-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># We access the first element [0] to get our specific scalar result.</span></span>
<span id="cb5-13">expectation_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> result.data.evs</span>
<span id="cb5-14"></span>
<span id="cb5-15"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">Calculated Expectation Value &lt;v|A|v&gt;: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>expectation_value<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.6f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Calculated Expectation Value &lt;v|A|v&gt;: 0.299251</code></pre>
</div>
</div>
<p><strong>What just happened?</strong> The Estimator acted as our “Linear Algebra Calculator.”</p>
<ol type="1">
<li><strong>Input:</strong> It took a Circuit (a recipe for creating the vector <img src="https://latex.codecogs.com/png.latex?v">) and an Operator (the decomposition of matrix <img src="https://latex.codecogs.com/png.latex?A">).</li>
<li><strong>Process:</strong> It handled the basis rotations and measurements internally (splitting ZZ and XX into different measurement jobs if needed).</li>
<li><strong>Output:</strong> It returned the scalar value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</li>
</ol>
<p><strong>Next Steps:</strong> In the next post, we will finally close the loop. We will replace our fixed manual angles with <strong>variables</strong>, introducing the <strong>Ansatz</strong>, and use a classical optimization algorithm to find the specific angles that minimize our energy.</p>


</section>
</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Qiskit</category>
  <category>Linear Algebra</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/03-encoding-math-into-metal.html</guid>
  <pubDate>Tue, 02 Dec 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>The Variational Principle: A Linear Algebra Perspective</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/02-variational-principle.html</link>
  <description><![CDATA[ 





<p>In my <a href="https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html">previous post</a>, “Challenge Accepted,” I set the stage for exploring quantum diagonalization. Since then, I’ve been diving deeper into the material, specifically reading the first lesson of the <a href="https://quantum.cloud.ibm.com/learning/en/courses/quantum-diagonalization-algorithms/vqe">IBM Variational Quantum Algorithms course</a>.</p>
<p>As I digested the material, I started thinking about the basic concepts that underpin the Variational Quantum Eigensolver (VQE). It’s easy to get lost in the quantum mechanics immediately, but the heart of the method actually lies in standard linear algebra.</p>
<section id="from-eigenvalues-to-expectation-values" class="level2">
<h2 class="anchored" data-anchor-id="from-eigenvalues-to-expectation-values">From Eigenvalues to Expectation Values</h2>
<p>We traditionally encounter eigenvalues and eigenvectors as the solutions to the characteristic equation:</p>
<p><img src="https://latex.codecogs.com/png.latex?Ax%20=%20%5Clambda%20x"></p>
<p>If we assume our vector <img src="https://latex.codecogs.com/png.latex?x"> is normalized (has a length of 1), we can perform a simple manipulation. By multiplying both sides by the transpose of <img src="https://latex.codecogs.com/png.latex?x"> (denoted as <img src="https://latex.codecogs.com/png.latex?x%5ET">), we can rewrite this relationship to isolate the eigenvalue <img src="https://latex.codecogs.com/png.latex?%5Clambda">:</p>
<p><img src="https://latex.codecogs.com/png.latex?x%5ET%20A%20x%20=%20%5Clambda"></p>
<p>In many problems, particularly in physics and chemistry, we aren’t looking for just <em>any</em> eigenvalue; we are hunting for the <strong>lowest eigenvalue</strong> (the ground state energy). Let’s call this lowest eigenvalue <img src="https://latex.codecogs.com/png.latex?%5Clambda_0">, which corresponds to a specific eigenvector <img src="https://latex.codecogs.com/png.latex?x_0">:</p>
<p><img src="https://latex.codecogs.com/png.latex?x_0%5ET%20A%20x_0%20=%20%5Clambda_0"></p>
<p>This concept can be visualized as a search on a complex energy landscape. Our goal is to navigate this landscape to find the absolute lowest point, the global minimum.</p>
<div id="fig-energy-landscape" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A 3D surface plot showing a complex energy landscape with hills and valleys, highlighting a single global minimum point representing the ground state energy.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-energy-landscape-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" class="img-fluid figure-img" alt="A 3D surface plot showing a complex energy landscape with hills and valleys, highlighting a single global minimum point representing the ground state energy.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-energy-landscape-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Geometric interpretation of an energy landscape, showing optimization paths descending towards the global minimum (ground state).
</figcaption>
</figure>
</div>
<p>This brings us to a fundamental property known as the <strong>Variational Principle</strong>. It states that if you take <em>any</em> arbitrary normalized vector <img src="https://latex.codecogs.com/png.latex?v"> and compute this product, the result will always be greater than or equal to the lowest eigenvalue:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0"></p>
<p>If you are interested in the mathematical rigor behind this principle, you can expand the section below for a step-by-step proof.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Proof: The Variational Principle (Click to expand)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>To prove that <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0">, we rely on the <strong>Spectral Theorem</strong>. Since <img src="https://latex.codecogs.com/png.latex?A"> represents a physical observable (like a Hamiltonian), it is a Hermitian matrix. This guarantees two things:</p>
<ol type="1">
<li>All its eigenvalues <img src="https://latex.codecogs.com/png.latex?%5Clambda_i"> are real.</li>
<li>Its eigenvectors <img src="https://latex.codecogs.com/png.latex?%5C%7Bx_0,%20x_1,%20%5Cdots,%20x_%7Bn-1%7D%5C%7D"> form a complete orthonormal basis.</li>
</ol>
<p>Let’s order the eigenvalues such that <img src="https://latex.codecogs.com/png.latex?%5Clambda_0%20%5Cle%20%5Clambda_1%20%5Cle%20%5Cdots%20%5Cle%20%5Clambda_%7Bn-1%7D">.</p>
<p>Since the eigenvectors form a basis, any arbitrary vector <img src="https://latex.codecogs.com/png.latex?v"> can be written as a linear combination of these eigenvectors:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%20=%20%5Csum_%7Bi%7D%20c_i%20x_i"></p>
<p>Because <img src="https://latex.codecogs.com/png.latex?v"> is normalized (<img src="https://latex.codecogs.com/png.latex?v%5ET%20v%20=%201">) and the basis is orthonormal (<img src="https://latex.codecogs.com/png.latex?x_i%5ET%20x_j%20=%20%5Cdelta_%7Bij%7D">), the sum of the squared coefficients must equal 1:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20=%201"></p>
<p>Now, let’s look at the action of <img src="https://latex.codecogs.com/png.latex?A"> on this expansion:</p>
<p><img src="https://latex.codecogs.com/png.latex?A%20v%20=%20A%20%5Cleft(%20%5Csum_%7Bi%7D%20c_i%20x_i%20%5Cright)%20=%20%5Csum_%7Bi%7D%20c_i%20(A%20x_i)%20=%20%5Csum_%7Bi%7D%20c_i%20%5Clambda_i%20x_i"></p>
<p>Next, we calculate the expectation value <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20=%20%5Cleft(%20%5Csum_%7Bj%7D%20c_j%20x_j%20%5Cright)%5ET%20%5Cleft(%20%5Csum_%7Bi%7D%20c_i%20%5Clambda_i%20x_i%20%5Cright)"></p>
<p>Due to the orthonormality of the eigenvectors (the product <img src="https://latex.codecogs.com/png.latex?x_j%5ET%20x_i"> is 1 if <img src="https://latex.codecogs.com/png.latex?i=j"> and 0 otherwise), the cross-terms vanish, leaving us with a weighted sum of the eigenvalues:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20=%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_i"></p>
<p>Here is the crucial step. Since <img src="https://latex.codecogs.com/png.latex?%5Clambda_0"> is the smallest eigenvalue, we know that <img src="https://latex.codecogs.com/png.latex?%5Clambda_i%20%5Cge%20%5Clambda_0"> for all <img src="https://latex.codecogs.com/png.latex?i">. Therefore, we can replace <img src="https://latex.codecogs.com/png.latex?%5Clambda_i"> with <img src="https://latex.codecogs.com/png.latex?%5Clambda_0"> to form an inequality:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_i%20%5Cge%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Clambda_0"></p>
<p>We can factor out <img src="https://latex.codecogs.com/png.latex?%5Clambda_0">:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0%20%5Cleft(%20%5Csum_%7Bi%7D%20%7Cc_i%7C%5E2%20%5Cright)"></p>
<p>Since <img src="https://latex.codecogs.com/png.latex?%5Csum%20%7Cc_i%7C%5E2%20=%201">, the proof is complete:</p>
<p><img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v%20%5Cge%20%5Clambda_0"></p>
</div>
</div>
</div>
</section>
<section id="turning-algebra-into-optimization" class="level2">
<h2 class="anchored" data-anchor-id="turning-algebra-into-optimization">Turning Algebra into Optimization</h2>
<p>This inequality gives us a clear strategy. To find the lowest eigenvalue, we don’t need to analytically solve the matrix equation. Instead, we can treat it as a minimization game: we need to try different vectors <img src="https://latex.codecogs.com/png.latex?v"> until we find the one that produces the lowest possible value for <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>However, trying vectors blindly is not efficient. The vector space is simply too vast. To make this manageable, we transform the search into an <strong>optimization problem</strong>.</p>
<p>Instead of picking random vectors, we construct a vector that depends on a set of tunable scalar parameters. Let’s say we have a problem with <img src="https://latex.codecogs.com/png.latex?n"> dimensions; theoretically, we need at most <img src="https://latex.codecogs.com/png.latex?n"> parameters to explore the space. We can denote this parameterized vector as <img src="https://latex.codecogs.com/png.latex?v(%5Ctheta)">. By tweaking these <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> parameters, we navigate the vector space, searching for the minimum value.</p>
</section>
<section id="the-complexity-barrier-and-the-quantum-solution" class="level2">
<h2 class="anchored" data-anchor-id="the-complexity-barrier-and-the-quantum-solution">The Complexity Barrier and the Quantum Solution</h2>
<p>This sounds straightforward enough to handle classically, so why do we need a quantum computer?</p>
<p>The problem lies in the complexity. As the system we are studying grows (for example, adding more atoms to a molecule), the dimension of the matrix <img src="https://latex.codecogs.com/png.latex?A"> explodes exponentially. For a system that is still relatively small in physical terms, the vector <img src="https://latex.codecogs.com/png.latex?v"> becomes so large that a classical supercomputer cannot even store it, let alone perform the matrix multiplications required to calculate <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v">.</p>
<p>The chart below illustrates this dramatic difference in scaling. While classical resources grow exponentially, a quantum algorithm like VQE offers a much more favorable polynomial scaling.</p>
<div id="fig-complexity" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A line chart on a semi-log scale comparing the exponential growth of classical computational resources against the polynomial growth of quantum VQE resources as the system size increases.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_1.png" class="img-fluid figure-img" alt="A line chart on a semi-log scale comparing the exponential growth of classical computational resources against the polynomial growth of quantum VQE resources as the system size increases.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Comparison of computational resource scaling for classical simulation (exponential) versus Quantum VQE (polynomial) as a function of system size.
</figcaption>
</figure>
</div>
<p>This is where the quantum connection is made. In quantum mechanics, the expression <img src="https://latex.codecogs.com/png.latex?v%5ET%20A%20v"> is written using Dirac notation as:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle"></p>
<p>This is known as the <strong>quantum expectation value</strong>.</p>
<p>While calculating this is a choking point for classical computers, it is a native operation for a quantum computer. We can prepare the state <img src="https://latex.codecogs.com/png.latex?%7Cv%5Crangle"> on a quantum processor and measure the expectation value of the operator <img src="https://latex.codecogs.com/png.latex?A"> directly. This allows us to evaluate our “cost function” efficiently, while a classical computer handles the task of updating the parameters <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> to drive us toward the solution.</p>
<p><strong>Next Steps:</strong> In my next post, I will dive into the implementation details: specifically, how we efficiently create these parameterized vectors (the <em>ansatz</em> - German for ‘approach’ or ‘trial’) on actual quantum hardware, and the precise circuits required to measure the quantum expectation value <img src="https://latex.codecogs.com/png.latex?%5Clangle%20v%20%7C%20A%20%7C%20v%20%5Crangle">.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Linear Algebra</category>
  <category>VQE</category>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/02-variational-principle.html</guid>
  <pubDate>Sun, 30 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/image_0.png" medium="image" type="image/png" height="101" width="144"/>
</item>
<item>
  <title>Challenge Accepted: Mastering Quantum Diagonalization (It’s Not Just for Molecules)</title>
  <link>https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html</link>
  <description><![CDATA[ 





<p>Yesterday, I attended a Qiskit Advocate seminar on <strong>Sample-Based Quantum Diagonalization (SQD)</strong>. The session was a fascinating deep dive into how we can extract eigenvalues from complex Hamiltonians using advanced sampling techniques. It was a reminder of just how powerful hybrid quantum algorithms are becoming for research.</p>
<p>But it also prompted a personal challenge.</p>
<p>As I watched the presentation, I realized that while I grasp the concepts, I want to get my hands dirty with the implementation details of the foundational solvers that lead up to SQD. To truly appreciate the cutting edge, one must master the building blocks.</p>
<p>So, I am kicking off a new learning sprint. I have officially enrolled in the <a href="https://quantum.cloud.ibm.com/learning/en/courses/quantum-diagonalization-algorithms">IBM Quantum Learning course on Quantum Diagonalization Algorithms</a>. Over the coming weeks, this blog series will serve as my lab notebook—documenting the code, the math, and the results as I attempt to diagonalize matrices on real quantum backends.</p>
<section id="why-diagonalization-matters-beyond-physics" class="level2">
<h2 class="anchored" data-anchor-id="why-diagonalization-matters-beyond-physics">Why “Diagonalization” Matters (Beyond Physics)</h2>
<p>If you look at most quantum computing tutorials, “diagonalization” is almost exclusively framed as a chemistry problem: <em>Find the ground state energy of a molecule.</em></p>
<p>While simulating nature is a killer application, as a Computer Scientist, I want to broaden the aperture. Mathematically, diagonalizing a matrix <img src="https://latex.codecogs.com/png.latex?A"> simply means finding the basis in which <img src="https://latex.codecogs.com/png.latex?A"> acts as a simple scaling factor. We are solving for eigenvectors (<img src="https://latex.codecogs.com/png.latex?v">) and eigenvalues (<img src="https://latex.codecogs.com/png.latex?%5Clambda">):</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AAv%20=%20%5Clambda%20v%0A"></p>
<p>In my view, this isn’t just about electron orbitals. This is about <strong>extracting the defining features of a system</strong>. The algorithms I’ll be exploring in this course—VQE, Quantum Krylov, and Phase Estimation—are actually universal mathematical tools that apply directly to classic CS and Data Science problems:</p>
<section id="graph-theory-spectral-clustering" class="level3">
<h3 class="anchored" data-anchor-id="graph-theory-spectral-clustering">1. Graph Theory &amp; Spectral Clustering</h3>
<p>In social network analysis, we use the <strong>Graph Laplacian</strong> matrix. Diagonalizing this matrix helps us find the “Fiedler Vector,” which tells us the optimal way to cut a graph into disconnected communities. It’s not energy; it’s <em>clustering</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://dikranmeliksetian.com/posts/quantum_diagonalization/img/spectral-cut.png" class="img-fluid figure-img"></p>
<figcaption>A visualization of a Spectral Clustering Cut</figcaption>
</figure>
</div>
</section>
<section id="data-science-pca" class="level3">
<h3 class="anchored" data-anchor-id="data-science-pca">2. Data Science &amp; PCA</h3>
<p>In Machine Learning, <strong>Principal Component Analysis (PCA)</strong> relies on diagonalizing the Covariance Matrix. The eigenvectors with the largest eigenvalues represent the features that matter most in a massive dataset. A quantum eigensolver is effectively a pattern recognition engine.</p>
</section>
<section id="system-dynamics" class="level3">
<h3 class="anchored" data-anchor-id="system-dynamics">3. System Dynamics</h3>
<p>In Markov chains (like the math powering PageRank), the steady state of a system is simply the eigenvector with an eigenvalue of 1.</p>
</section>
</section>
<section id="the-syllabus-my-roadmap" class="level2">
<h2 class="anchored" data-anchor-id="the-syllabus-my-roadmap">The Syllabus: My Roadmap</h2>
<p>This course moves beyond the “Hello World” of quantum. Here is the roadmap of algorithms I plan to implement and stress-test:</p>
<ul>
<li><strong>The Heuristic Layer:</strong> Deep diving into <strong>VQE (Variational Quantum Eigensolver)</strong>, specifically looking at efficient ansatz construction for non-chemistry problems.</li>
<li><strong>The Subspace Layer:</strong> This is the bridge to the seminar I attended. I will be exploring <strong>Quantum Subspace Expansion</strong> and <strong>Krylov methods</strong>, which project large problems into smaller, manageable subspaces.</li>
<li><strong>The Precision Layer:</strong> Finally, looking at <strong>Quantum Phase Estimation (QPE)</strong>, the “textbook” algorithm that offers exponential speedup but demands significant resources.</li>
</ul>
</section>
<section id="the-commitment" class="level2">
<h2 class="anchored" data-anchor-id="the-commitment">The Commitment</h2>
<p>I intend to approach this not just as a student, but as an engineer and educator.</p>
<p>I won’t just post the “happy path” where the code works perfectly on a simulator. I plan to run these algorithms on IBM’s utility-scale quantum systems. I will document the noise, the convergence failures, and the error mitigation strategies (like Zero Noise Extrapolation) required to get a clean signal out of a real device.</p>
<p><strong>Next up:</strong> I’ll be tackling the Graph Laplacian and seeing if we can use a quantum computer to solve a classic clustering problem.</p>


</section>

 ]]></description>
  <guid>https://dikranmeliksetian.com/posts/quantum_diagonalization/01-challenge-accepted.html</guid>
  <pubDate>Wed, 26 Nov 2025 05:00:00 GMT</pubDate>
</item>
<item>
  <title>The Quantum Pigeonhole Paradox in Qiskit 2.x</title>
  <dc:creator>Dikran Meliksetian</dc:creator>
  <link>https://dikranmeliksetian.com/posts/quantum-pigeonhole/</link>
  <description><![CDATA[ 





<p>I have released a new tutorial exploring one of the most counter-intuitive results in quantum mechanics: <strong>The Quantum Pigeonhole Paradox</strong>.</p>
<p>Classically, the <strong>Pigeonhole Principle</strong> states that if you put three pigeons into two boxes, at least one box must contain more than one pigeon. In the quantum realm, however, using <strong>pre-selection</strong> and <strong>post-selection</strong>, we can construct a scenario where we can verify that <strong>no two particles share a box</strong>.</p>
<section id="what-this-tutorial-covers" class="level3">
<h3 class="anchored" data-anchor-id="what-this-tutorial-covers">What this Tutorial Covers</h3>
<p>In this <a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox">Qiskit 2.x notebook</a>, we explore:</p>
<ol type="1">
<li><strong>The Paradox Setup:</strong> Constructing the circuit for three particles and two boxes (states <img src="https://latex.codecogs.com/png.latex?%7CL%5Crangle"> and <img src="https://latex.codecogs.com/png.latex?%7CR%5Crangle">).</li>
<li><strong>The Measurement Problem:</strong> Demonstrating how a standard “strong” measurement collapses the state and destroys the paradox.</li>
<li><strong>Weak Measurements:</strong> Using a weak, reversible probe (Compute <img src="https://latex.codecogs.com/png.latex?%5Crightarrow%20R_y(%5Cepsilon)%20%5Crightarrow"> Uncompute) to extract information without collapsing the interference pattern.</li>
<li><strong>Interference Recovery:</strong> Observing how the paradox re-emerges when we limit the disturbance to the system.</li>
</ol>
</section>
<section id="key-insight" class="level3">
<h3 class="anchored" data-anchor-id="key-insight">Key Insight</h3>
<p>This paradox forces us to reconsider the nature of trajectories and correlations in quantum systems. It demonstrates that “logic” about the past (e.g., “which box were they in?”) depends heavily on the measurement strength and the post-selection choice.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Run the Code
</div>
</div>
<div class="callout-body-container callout-body">
<p>This tutorial is open-source and compatible with <strong>Qiskit 2.x</strong>. You can view the full derivation and run the simulation yourself.</p>
</div>
</div>
<div class="grid">
<div class="g-col-12 g-col-md-6">
<p><a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox" class="btn btn-outline-primary w-100"><i class="bi bi-github"></i> View on GitHub</a></p>
</div>
<div class="g-col-12 g-col-md-6">
<p><a href="https://github.com/dmeliksetian/quantum_pigeonhole_paradox/blob/main/quantum_pigeonhole_paradox_qiskit_tutorial.ipynb" class="btn btn-primary w-100"><i class="bi bi-journal-code"></i> Read the Notebook</a></p>
</div>
</div>
<p><strong>Citation:</strong> &gt; Dikran Meliksetian, <em>The Quantum Pigeonhole Paradox in Qiskit 2.x: From Strong to Weak Measurements</em>, DOI: <a href="https://doi.org/10.5281/zenodo.17387139">10.5281/zenodo.17387139</a>.</p>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Qiskit</category>
  <category>Weak Measurements</category>
  <category>Paradoxes</category>
  <guid>https://dikranmeliksetian.com/posts/quantum-pigeonhole/</guid>
  <pubDate>Tue, 25 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/quantum-pigeonhole/review.png" medium="image" type="image/png" height="46" width="144"/>
</item>
<item>
  <title>Welcome to My Research Blog</title>
  <dc:creator>Dikran Meliksetian, Ph.D.</dc:creator>
  <link>https://dikranmeliksetian.com/posts/welcome/</link>
  <description><![CDATA[ 





<p>Welcome to my personal research blog.</p>
<p>After a career driving technical strategy as a Chief Architect and IBM Master Inventor, and now investigating the frontiers of computer science in academia, I find that the most interesting problems lie at the intersection of theory and practice.</p>
<section id="focus-areas" class="level2">
<h2 class="anchored" data-anchor-id="focus-areas">Focus Areas</h2>
<p>This blog serves as a digital notebook for my ongoing research and intellectual explorations. You can expect technical deep dives and reflections on:</p>
<ol type="1">
<li><p><strong>Quantum Frontiers &amp; QML:</strong> Exploring the transition from classical to quantum architectures. I will be discussing developments in Quantum Error Correction and Qiskit, with a specific focus on how <strong>AI and Machine Learning</strong> are being used to optimize quantum circuits and mitigate noise.</p></li>
<li><p><strong>The Architecture of Innovation:</strong> Reflections on patenting, system design, and the methodologies that turn abstract ideas into scalable technologies. I will explore how Generative AI acts as a catalyst for invention and how it is fundamentally altering the software development lifecycle.</p></li>
<li><p><strong>The AI-Augmented Workflow:</strong> Beyond the technology itself, I am interested in the <em>meta-analysis</em> of work. How are Large Language Models (LLMs) changing the way we code, write, and research? I will be documenting how AI is reshaping my own professional practices—from accelerating code generation to assisting in complex problem decomposition.</p></li>
</ol>
</section>
<section id="join-the-conversation" class="level2">
<h2 class="anchored" data-anchor-id="join-the-conversation">Join the Conversation</h2>
<p>I intend for this space to foster discussion with fellow researchers, industry practitioners, and anyone fascinated by the capabilities and limitations of computing systems.</p>
<p>I welcome your insights and feedback on these topics.</p>
<footer id="contact" class="bg-slate-800 text-slate-100 py-16">
<div class="container mx-auto px-6 text-center">
<pre><code>&lt;h2 class="text-3xl font-bold mb-4"&gt;Get In Touch&lt;/h2&gt;
&lt;p class="max-w-xl mx-auto mb-8"&gt;I am always open to discussing new ideas, research opportunities, or interesting projects in the quantum computing space. Feel free to reach out.&lt;/p&gt;

&lt;div class="flex justify-center items-center flex-wrap gap-x-8 gap-y-4 text-lg mb-8"&gt;
  &lt;a href="mailto:dsmeliks@gmail.com" class="flex items-center space-x-2 hover:text-brand-light transition-colors"&gt;
    &lt;i class="fas fa-envelope w-6"&gt;&lt;/i&gt;
    &lt;span&gt;dikran.s.meliksetian@gmail.com (Personal)&lt;/span&gt;
  &lt;/a&gt;
  
  &lt;a href="mailto:dmeliksetian@newhaven.edu" class="flex items-center space-x-2 hover:text-brand-light transition-colors"&gt;
    &lt;i class="fas fa-university w-6"&gt;&lt;/i&gt;
    &lt;span&gt;dmeliksetian@newhaven.edu (Academic)&lt;/span&gt;
  &lt;/a&gt;
  
  &lt;div class="flex items-center space-x-2"&gt;
    &lt;i class="fas fa-map-marker-alt w-6"&gt;&lt;/i&gt;
    &lt;span&gt;Newtown, CT&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p class="text-sm text-slate-400"&gt;&amp;copy; &lt;span id="year"&gt;&lt;/span&gt; Dikran Meliksetian. All Rights Reserved.&lt;/p&gt;</code></pre>
</div>
</footer>
<script>
  const yearSpan = document.getElementById('year');
  if (yearSpan) {
    yearSpan.textContent = new Date().getFullYear();
  }
</script>


</section>

 ]]></description>
  <category>Quantum Computing</category>
  <category>Generative AI</category>
  <category>Innovation</category>
  <category>Productivity</category>
  <guid>https://dikranmeliksetian.com/posts/welcome/</guid>
  <pubDate>Sun, 23 Nov 2025 05:00:00 GMT</pubDate>
  <media:content url="https://dikranmeliksetian.com/posts/welcome/welcome_image.png" medium="image" type="image/png" height="79" width="144"/>
</item>
</channel>
</rss>
