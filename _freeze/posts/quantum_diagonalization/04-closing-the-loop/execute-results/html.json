{
  "hash": "0fc6973c90dcd011baef5f5c5119ab53",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Closing the Loop: From Fixed Angles to Optimization\"\ndate: 2025-12-12\ncategories: [Quantum Computing, VQE, Optimization]\nimage: img/image_0.png\ndescription: \"Turning constants into variables: How to build a parameterized quantum circuit and use classical optimization to find the minimum eigenvalue and eigenvector.\"\nformat:\n  html:\n    code-fold: show\nexecute:\n  enabled: true\n  freeze: true\n  keep-ipynb: true\njupyter: quantum\ndraft: false\n---\n\nIn our [last post](./03-encoding-math-into-metal.qmd), we successfully calculated the value $v^T A v$ for a *specific* vector $v$. We manually rotated our qubits by specific angles ($\\pi/3$ and $\\pi/4$), ran the Estimator, and verified that the result matched our classical calculation.\n\nBut in a real problem, we don't know the answer ahead of time. We don't know the specific angles that create the solution. We are searching for the **minimum eigenvalue** ($\\lambda_0$) and its corresponding **eigenvector** ($x_0$).\n\nTo find them, we must transition from a static calculation to a dynamic **optimization loop**.\n\n## 1. The Hybrid Loop\n\nThe quantum computer cannot \"find\" the minimum on its own. It is just a very expensive function evaluator. It takes a set of angles $\\vec{\\theta}$ and returns a cost $E$. The logic for *how* to change $\\vec{\\theta}$ to lower the cost lives on the classical computer.\n\nThis creates a hybrid feedback loop:\n\n1.  **Classical CPU:** Guesses a set of parameters $\\vec{\\theta}$ (e.g., $[0, 0]$).\n2.  **Quantum QPU (Estimator):** Prepares the state $|v(\\vec{\\theta})\\rangle$ and measures the expectation value $E = \\langle v(\\vec{\\theta}) | A | v(\\vec{\\theta}) \\rangle$.\n3.  **Classical CPU:** Looks at $E$. Is it lower than before?\n    * *Yes:* Move further in that direction.\n    * *No:* Try a different direction.\n4.  **Repeat** until the value converges to the minimum.\n\n## 2. Step A: Finding the Minimum Eigenvalue\n\nLet's make this concrete. We will use the **exact same matrix** from the previous post, but we will upgrade our circuit. Last time, we hard-coded `np.pi/3`. This time, we will insert a symbolic **Parameter** and let the optimizer find that value for us.\n\n**The Matrix ($A$):**\n$$A = 0.5 (Z \\otimes Z) + 0.2 (X \\otimes X)$$\n\n::: {#6b81da2e .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.primitives import StatevectorEstimator\nfrom scipy.optimize import minimize\n\n# Define the Hamiltonian\nhamiltonian = SparsePauliOp.from_list([(\"ZZ\", 0.5), (\"XX\", 0.2)])\nprint(f\"Target Hamiltonian: {hamiltonian}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTarget Hamiltonian: SparsePauliOp(['ZZ', 'XX'],\n              coeffs=[0.5+0.j, 0.2+0.j])\n```\n:::\n:::\n\n\n### Parameterizing the Circuit\nIn Qiskit, we use `Parameter` objects to create algebraic variables. These are the \"knobs\" our classical optimizer will turn.\n\n::: {#7329e61c .cell execution_count=2}\n``` {.python .cell-code}\n# 1. Define the Parameters\ntheta_0 = Parameter('θ0')\ntheta_1 = Parameter('θ1')\n\n# 2. Build the Circuit\n# Instead of fixed angles, we use the parameters.\nqc = QuantumCircuit(2)\nqc.ry(theta_0, 0) \nqc.ry(theta_1, 1)\n\nprint(\"Parameterized Circuit:\")\ndisplay(qc.draw(\"mpl\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameterized Circuit:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04-closing-the-loop_files/figure-html/cell-3-output-2.png){width=170 height=168}\n:::\n:::\n\n\n### The Cost Function\nWe need a standard Python function that the optimizer can call. This function takes a list of numbers (the current values of $\\vec{\\theta}$) and returns a single number (the eigenvalue estimate).\n\n::: {#d1056ea7 .cell execution_count=3}\n``` {.python .cell-code}\nestimator = StatevectorEstimator()\n\ndef cost_function(params):\n    \"\"\"\n    Input: params = [val_0, val_1]\n    Output: Expectation Value <v(params)|A|v(params)>\n    \"\"\"\n    # Bind the numerical values to the circuit parameters\n    pub = (qc, hamiltonian, params)\n    \n    # Run the job\n    job = estimator.run([pub])\n    result = job.result()[0]\n    \n    # Return the scalar float\n    # We explicitly cast to float to avoid numpy array issues in scipy\n    return float(result.data.evs)\n\n# Test it with a random guess to make sure it works\ntest_guess = [0.0, 0.0]\nprint(f\"Value at [0,0]: {cost_function(test_guess):.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue at [0,0]: 0.5000\n```\n:::\n:::\n\n\n### Running the Optimization\nWe use `scipy.optimize.minimize` with the **COBYLA** method. This is a \"gradient-free\" optimizer, often used in quantum computing because it handles noise better than standard gradient descent.\n\n::: {#c6b10330 .cell execution_count=4}\n``` {.python .cell-code}\n# 1. Initial Guess\ninitial_guess = [0.0, 0.0]\n\nprint(\"Starting Optimization...\")\n\n# 2. The Minimization Routine\nresult = minimize(cost_function, initial_guess, method='COBYLA')\n\n# 3. The Output\noptimal_angles = result.x\nmin_eigenvalue = result.fun\n\nprint(f\"\\nOptimization Complete!\")\nprint(f\"Optimal Angles found: {optimal_angles}\")\nprint(f\"Minimum Eigenvalue found: {min_eigenvalue:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting Optimization...\n\nOptimization Complete!\nOptimal Angles found: [3.14157719e+00 8.62918814e-05]\nMinimum Eigenvalue found: -0.500000\n```\n:::\n:::\n\n\nSuccess! The optimizer automatically found the angles that produce the minimum eigenvalue.\n\n## 3. Step B: Retrieving the Eigenvector\n\nWe have found the minimum eigenvalue ($\\lambda_0$), but in many applications (like data science or chemistry), we also need the **eigenvector** itself ($x_0$).\n\nThe **Estimator** only gives us the energy. To see the vector structure, we use the **Sampler**. The Sampler gives us the probability ($P$) of measuring each state. Since $P = |\\psi|^2$, we can reconstruct the magnitude of the state vector.\n\n*Note: The Sampler recovers the magnitude, but not the relative phases (signs). For that, we would need more complex tomography. For now, we compare the probability distributions.*\n\n::: {#751ff8e0 .cell execution_count=5}\n``` {.python .cell-code}\nfrom qiskit.primitives import StatevectorSampler\n\n# 1. Prepare the Circuit for Sampling\nqc_sampled = qc.copy()\nqc_sampled.measure_all()\n\n# 2. Run the Sampler using the OPTIMAL angles\nsampler = StatevectorSampler()\njob_sampler = sampler.run([(qc_sampled, optimal_angles)])\nresult_sampler = job_sampler.result()[0]\n\n# 3. Reconstruct the Vector\n# Get counts and convert to probabilities\ncounts = result_sampler.data.meas.get_counts()\ntotal_shots = sum(counts.values())\n\n# We strictly order the states: |00>, |01>, |10>, |11>\nstates = ['00', '01', '10', '11']\n\n# Calculate Probabilities\nprobs = np.array([counts.get(s, 0) / total_shots for s in states])\n\n# Calculate Amplitudes (Sqrt of probability)\nquantum_vector = np.sqrt(probs)\n\nprint(\"Reconstructed Quantum Eigenvector:\")\nprint(quantum_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReconstructed Quantum Eigenvector:\n[0. 1. 0. 0.]\n```\n:::\n:::\n\n\n## 4. The Reality Check: Did we fail?\n\nWe have an answer. The optimization loop converged successfully. But is it the *correct* answer?\n\nLet's verify this using standard linear algebra tools like `numpy`. We will construct the matrix $A$ explicitly, diagonalize it, and find the true eigenvector.\n\n::: {#2ead9564 .cell execution_count=6}\n``` {.python .cell-code}\n# 1. Construct the Matrix A Classically\n# A = 0.5*ZZ + 0.2*XX\nmatrix_A = np.array([\n    [0.5, 0,   0,   0.2],\n    [0,  -0.5, 0.2, 0  ],\n    [0,   0.2,-0.5, 0  ],\n    [0.2, 0,   0,   0.5]\n])\n\n# 2. Calculate Eigenvalues and Eigenvectors\neigenvals, eigenvecs = np.linalg.eigh(matrix_A)\n\n# 3. Extract the Minimum\ntrue_eigenvalue = eigenvals[0]\ntrue_eigenvector = eigenvecs[:, 0]\n\n# 4. Take absolute value for comparison (ignoring phase signs)\ntrue_vector_abs = np.abs(true_eigenvector)\n\nprint(f\"True Minimum Eigenvalue: {true_eigenvalue:.6f}\")\nprint(f\"True Eigenvector (Abs):  {true_vector_abs}\")\nprint(\"-\" * 30)\nprint(f\"Quantum Value Found:     {min_eigenvalue:.6f}\")\nprint(f\"Quantum Vector Distance: {np.linalg.norm(quantum_vector - true_vector_abs):.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue Minimum Eigenvalue: -0.700000\nTrue Eigenvector (Abs):  [0.         0.70710678 0.70710678 0.        ]\n------------------------------\nQuantum Value Found:     -0.500000\nQuantum Vector Distance: 0.765367\n```\n:::\n:::\n\n\n### The Discrepancy\n\nLook at the results above.\n1.  **The Value:** The quantum result is significantly higher than the true minimum.\n2.  **The Vector:** The distance is large (likely $>0.7$).\n\nThe code worked perfectly. The optimizer did its job. Yet, we failed to find the ground state. **Why?**\n\nThe answer lies in the **Ansatz** (the circuit structure). We constructed our circuit using only independent rotations (`RY` on qubit 0, `RY` on qubit 1).\n\n$$|\\psi\\rangle = (a|0\\rangle + b|1\\rangle) \\otimes (c|0\\rangle + d|1\\rangle)$$\n\nThe classical calculation reveals that the true ground state is a **Bell State** approximation—a **maximally entangled** state where the qubits are correlated.\n\nMathematically, a tensor product of single qubits (which is all our current circuit can produce) can **never** create an entangled state. We tried to fit a round peg (an entangled ground state) into a square hole (a product-state circuit).\n\nNo matter how long we run the optimizer, we will never reach the true minimum because it physically does not exist in the search space of our current circuit.\n\n**Next Steps:** We have the Engine (VQE loop), but we need better Fuel. In the next post, we will break the \"Product State Barrier\" by introducing **Entanglement** and designing a **Hardware Efficient Ansatz**.\n\n",
    "supporting": [
      "04-closing-the-loop_files"
    ],
    "filters": [],
    "includes": {}
  }
}