{
  "hash": "2cf4f443f00b1602d5fbd4d808ccbc05",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The Implicit Matrix: Scaling Max-Cut with Paulis\"\ndate: 2026-01-21\ncategories: [Quantum Computing, VQE, Hamiltonian]\nimage: img/maxcut_decomposition.png\ndescription: \"We use the Max-Cut problem to demonstrate how to transition from a classical matrix formulation to a quantum operator without ever building the full dense matrix.\"\nformat:\n  html:\n    code-fold: show\nexecute:\n  enabled: true\n  freeze: true\n  keep-ipynb: true\njupyter: quantum\ndraft: false\n---\n\n\n\nIn our **[previous post](./06-exploring-the-ansatz-zoo.qmd)**, we solved the \"Parameter Wall\" by using Heuristic Ansatzes. This allowed us to represent a complex quantum state $|\\psi\\rangle$ with just a few dozen parameters.\n\nBut VQE has two parts:\n$$E = \\langle \\psi | H | \\psi \\rangle$$\n\nWe fixed $|\\psi\\rangle$ (the vector). Now we must fix $H$ (the matrix).\n\nIt is only in textbook exercises that we are given a matrix and asked to find the lowest eigenvalue and the corresponding eigenvector. In real-world scenarios, we are almost never \"given\" the matrix. Instead, we start from a **problem definition**—a graph, a molecule, or a financial model.\n\nOur job is to cast that problem as an eigenvalue/eigenvector problem. The general approach is to construct the **Hamiltonian** ($H$) directly from the problem definition. For large systems (e.g., 50 variables), we must do this **implicitly**, building $H$ as a sum of Pauli strings without ever generating the full $2^N \\times 2^N$ matrix.\n\nIn this post, we will use the **Max-Cut Problem** to illustrate this approach step-by-step.\n\n## 1. The Setup: Defining the Graph\n\n**The Goal:** Divide the nodes of a graph into two groups (colors) such that the number of edges connecting different colors is maximized.\n\nLet's define a simple graph with 5 nodes.\n\n::: {#c185daee .cell execution_count=1}\n``` {.python .cell-code}\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 1. Define the Graph\nnum_nodes = 5\nedges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (0, 2)]\n\nG = nx.Graph()\nG.add_nodes_from(range(num_nodes))\nG.add_edges_from(edges)\n\n# 2. Draw the Graph\nplt.figure(figsize=(6, 4))\npos = nx.spring_layout(G, seed=42)\nnx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=700, font_weight='bold')\nplt.title(\"5-Node Graph for Max-Cut\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](07-matrix-decomposition_files/figure-html/cell-2-output-1.png){width=595 height=423}\n:::\n:::\n\n\n## 2. The Classical Cost: $\\sum (x_i - x_j)^2$\n\nBefore we look at quantum operators, let's define the problem mathematically.\n\nWe represent the solution as a vector of binary variables $x \\in \\{0, 1\\}^N$.\n\n* $x_i = 0$ means Node $i$ is in Group A.\n* $x_i = 1$ means Node $i$ is in Group B.\n\nFor every edge $(i, j)$, we want to check if the nodes are in different groups. We can do this with the squared difference:\n$$C_{ij} = (x_i - x_j)^2$$\n\n* If $x_i = x_j$ (Same Group): $(0-0)^2 = 0$ or $(1-1)^2 = 0$.\n* If $x_i \\neq x_j$ (Different Group): $(0-1)^2 = 1$ or $(1-0)^2 = 1$.\n\nThe total size of the cut is the sum over all edges:\n$$\\text{Cut Size} = \\sum_{(i,j) \\in E} (x_i - x_j)^2$$\n\n### Matrix Form (The Laplacian)\nThis sum can be written elegantly using matrix notation.\n$$\\sum_{(i,j) \\in E} (x_i - x_j)^2 = x^T L x$$\nwhere $L$ is the **Laplacian Matrix** ($L = D - A$).\n\nTo maximize the cut using a minimization algorithm (like VQE), we define our energy as negative:\n$$E(x) = - \\sum_{(i,j) \\in E} (x_i - x_j)^2 = -x^T L x$$\n\nLet's verify this classically.\n\n::: {#d8b763fc .cell execution_count=2}\n``` {.python .cell-code}\n# 1. Compute Laplacian L = D - A\nL = nx.laplacian_matrix(G).todense()\nprint(\"Laplacian Matrix L:\")\nprint(L)\n\n# 2. Evaluate Cost for every possible bitstring\ndim = 2**num_nodes\nbest_energy = 0\nbest_x = None\n\nfor k in range(dim):\n    # Convert integer k to binary vector x (e.g., [1, 0, 1, ...])\n    x = np.array([(k >> i) & 1 for i in range(num_nodes)])\n    \n    # Calculate Energy: E = - x^T L x\n    energy = - (x.T @ L @ x)\n    \n    # Track the minimum (most negative is best)\n    if energy < best_energy:\n        best_energy = energy\n        best_x = x\n\nprint(f\"\\nMax Cut Size:       {-best_energy}\")\nprint(f\"Best Configuration: {best_x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLaplacian Matrix L:\n[[ 3 -1 -1  0 -1]\n [-1  2 -1  0  0]\n [-1 -1  3 -1  0]\n [ 0  0 -1  2 -1]\n [-1  0  0 -1  2]]\n\nMax Cut Size:       5\nBest Configuration: [1 0 0 1 0]\n```\n:::\n:::\n\n\n## 3. The \"Implicit\" Operator (The Quantum Map)\n\nClassically, computing $x^T L x$ is fast for one vector. But finding the *best* vector requires checking all $2^N$ possibilities. To solve this on a quantum computer, we need to convert the binary variables $x_i$ into quantum operators.\n\nLet's do this step-by-step, dotting every 'i' and crossing every 't'.\n\n### Step 3a: The Observable (Pauli Z)\n\nWe need a quantum operator that behaves like a classical bit check. When we measure it, it should tell us if the qubit is in state $|0\\rangle$ or $|1\\rangle$.\n\nThe operator that does this is the **Pauli Z matrix**:\n\n$$Z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}$$\n\nWhen we apply this operator to our computational basis states, the resulting **eigenvalues** act as our labels:\n\n1.  **State $|0\\rangle$ (Group A):**\n    $$Z |0\\rangle = (+1)|0\\rangle$$\n    The eigenvalue is **+1**.\n\n2.  **State $|1\\rangle$ (Group B):**\n    $$Z |1\\rangle = (-1)|1\\rangle$$\n    The eigenvalue is **-1**.\n\nSo, while the qubit is the *object*, the Pauli $Z$ is the *tool* we use to extract a value (+1 or -1) that corresponds to our classical bits (0 or 1).\n\n### Step 3b: Mapping Binary ($x$) to Eigenvalues ($\\lambda$)\nWe need a linear equation that maps our binary variables $x \\in \\{0, 1\\}$ to these eigenvalues $\\lambda \\in \\{+1, -1\\}$.\n\n* We want $x=0$ (Group A) to map to $\\lambda=+1$.\n* We want $x=1$ (Group B) to map to $\\lambda=-1$.\n\nThe equation that achieves this is:\n$$\\lambda = 1 - 2x$$\n\nLet's check:\n\n* If $x=0 \\implies \\lambda = 1 - 0 = 1$. (Correct)\n* If $x=1 \\implies \\lambda = 1 - 2 = -1$. (Correct)\n\n### Step 3c: The Operator Substitution\nNow we invert that equation to express $x$ in terms of the operator $Z$.\nSince $\\lambda$ corresponds to the operator $Z$, we can write:\n\n$$Z = I - 2x \\quad \\implies \\quad x = \\frac{I - Z}{2}$$\n\nThis is the key. Anywhere we see $x_i$ in our classical equation, we replace it with the operator $\\frac{I - Z_i}{2}$.\n\n### Step 3d: Deriving the Hamiltonian\nWe take our classical cost function (from Section 2) and perform the substitution directly.\n\n$$(x_i - x_j)^2 = \\left( \\frac{I - Z_i}{2} - \\frac{I - Z_j}{2} \\right)^2$$\n\nWe factor out the $\\frac{1}{2}$:\n$$= \\frac{1}{4} \\left( (I - Z_i) - (I - Z_j) \\right)^2$$\n\nThe $I$'s cancel out:\n$$= \\frac{1}{4} (Z_j - Z_i)^2$$\n\nExpand the square:\n$$= \\frac{1}{4} (Z_j^2 - Z_j Z_i - Z_i Z_j + Z_i^2)$$\n\nWe know that $Z^2 = I$ (Pauli matrices are their own inverse) and $Z_i, Z_j$ commute on different qubits ($Z_i Z_j = Z_j Z_i$):\n$$= \\frac{1}{4} (I - 2 Z_i Z_j + I)$$\n$$= \\frac{1}{2} (I - Z_i Z_j)$$\n\nThis is our final Hamiltonian term for one edge.\nTo **minimize energy** (equivalent to maximizing the cut), we simply flip the sign:\n\n$$H_{edge} = \\frac{1}{2} (Z_i Z_j - I)$$\n\nWe can construct this **implicitly** for the whole graph by iterating over the edges. We map Node 0 to the first index of our list, Node 1 to the second, and so on.\n\n::: {#ebccfe18 .cell execution_count=3}\n``` {.python .cell-code}\nfrom qiskit.quantum_info import SparsePauliOp\n\npauli_list = []\ncoeffs = []\n\nfor u, v in edges:\n    # Each edge contributes 0.5 * (Z_i Z_j - I)\n    \n    # 1. The Interaction Term (0.5 * Z_i Z_j)\n    # Construct the string \"IIZIIZ...\"\n    op_list = [\"I\"] * num_nodes\n    op_list[u] = \"Z\"\n    op_list[v] = \"Z\"\n    \n    # Join directly (Map Node 0 -> Leftmost Char)\n    p_string = \"\".join(op_list)\n    \n    pauli_list.append(p_string)\n    coeffs.append(0.5)\n    \n    # 2. The Constant Term (-0.5 * I)\n    # We track this shift separately\n\n# Create the Operator\nH_quantum = SparsePauliOp(pauli_list, coeffs)\n\nprint(f\"Number of Pauli Terms: {len(H_quantum)}\")\nprint(H_quantum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of Pauli Terms: 6\nSparsePauliOp(['ZZIII', 'IZZII', 'IIZZI', 'IIIZZ', 'ZIIIZ', 'ZIZII'],\n              coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])\n```\n:::\n:::\n\n\n## 4. Solving with VQE (Noisy Simulation via V2 Primitives)\n\nNow we have the **Implicit Matrix** ($H$) and the **Implicit State** (Ansatz). We can solve the problem using VQE without ever storing $2^N$ numbers.\n\nTo demonstrate robust results, we will use a **Real Backend's Noise Model**, but execute on a local **Simulator**. We will use the modern **Primitives V2** interface (`BackendEstimatorV2` and `BackendSamplerV2`) which allows us to wrap our local simulator and treat it exactly like a cloud device.\n\n::: {#857b3a58 .cell execution_count=4}\n``` {.python .cell-code}\nfrom qiskit.circuit.library import real_amplitudes\nfrom scipy.optimize import minimize\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\n# Imports for the V2 Workflow\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime.fake_provider import FakeManilaV2\nfrom qiskit_aer import AerSimulator\nfrom qiskit.primitives import BackendEstimatorV2, BackendSamplerV2\n\n# 1. Fetch the Real Backend (Source of Truth)\nservice = QiskitRuntimeService()\nreal_backend = service.least_busy(operational=True, simulator=False, min_num_qubits=num_nodes)\nprint(f\"Fetching properties from Real Backend: {real_backend.name}\")\n\n# 2. Create a Local Simulator based on that Backend\n# This copies the coupling map, basis gates, and error rates to your local machine\naer_backend = AerSimulator.from_backend(real_backend)\nprint(f\"Running on: AerSimulator (mimicking {real_backend.name})\")\n\n# 3. Ansatz & Transpilation\nansatz = real_amplitudes(num_qubits=num_nodes, reps=3)\nansatz.measure_all() # Ensure we have measurements for the Sampler later\n\n# Transpile against the simulator (which matches the real topology)\npm = generate_preset_pass_manager(optimization_level=3, backend=aer_backend)\nisa_ansatz = pm.run(ansatz)\nisa_hamiltonian = H_quantum.apply_layout(isa_ansatz.layout)\n\nprint(\"Ansatz Transpiled for Hardware Topology.\")\n\n# 4. Initialize V2 Primitives\n# We wrap our local AerSimulator in the generic V2 wrappers\nestimator = BackendEstimatorV2(backend=aer_backend)\nsampler = BackendSamplerV2(backend=aer_backend)\n\n# Set the shots (precision)\nestimator.options.default_shots = 4000\nsampler.options.default_shots = 2000\n\ndef cost_function(params):\n    # V2 Syntax: Pass a list of PUBs (Primitive Unified Blocs)\n    # PUB format: (circuit, observables, parameter_values)\n    pub = (isa_ansatz, isa_hamiltonian, params)\n    \n    # Run Estimator\n    job = estimator.run([pub])\n    \n    # Return energy (evs = eigenvalues/expectation values)\n    return float(job.result()[0].data.evs)\n\n# 5. Optimization\nprint(\"Optimizing VQE parameters (local noisy simulation)...\")\ninitial_point = np.random.random(ansatz.num_parameters)\n# We use COBYLA as it is robust to noisy cost landscapes\nresult = minimize(cost_function, initial_point, method='COBYLA')\n\n# Adjust for the constant shift (-0.5 per edge)\nconstant_shift = -0.5 * len(edges)\nvqe_energy = result.fun + constant_shift\n\nprint(f\"VQE Noisy Energy: {vqe_energy:.4f}\")\nprint(f\"Classical Ideal:  {-best_energy:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFetching properties from Real Backend: ibm_torino\nRunning on: AerSimulator (mimicking ibm_torino)\nAnsatz Transpiled for Hardware Topology.\nOptimizing VQE parameters (local noisy simulation)...\nVQE Noisy Energy: -4.6692\nClassical Ideal:  5.0000\n```\n:::\n:::\n\n\n### Decoding the Solution\nThe energy tells us the size of the cut, but we need to know **how** to cut the graph. We sample the optimized circuit to find the most probable bitstring.\n\n::: {#240f0980 .cell execution_count=5}\n``` {.python .cell-code}\n# 1. Prepare optimized circuit\n# We assume the parameters from the result, but we must pass them in a PUB\n# for the Sampler (circuit, parameter_values)\npub = (isa_ansatz, result.x)\n\n# 2. Sample\njob = sampler.run([pub])\n# V2 Result Access: result[0].data.meas.get_counts()\n# Note: 'meas' is the name of the classical register (default is usually 'meas')\ncounts = job.result()[0].data.meas.get_counts()\n\n# 3. Display Counts in Decreasing Order\nsorted_counts = dict(sorted(counts.items(), key=lambda item: item[1], reverse=True))\n\nprint(\"Top 5 Results (Counts):\")\nfor bitstring, count in list(sorted_counts.items())[:5]:\n    print(f\"{bitstring}: {count}\")\n\n# 4. Visualize the Best Cut\nbest_bitstring = max(counts, key=counts.get)\nprint(f\"\\nWinning Configuration: {best_bitstring}\")\n\ncolors = []\n# Map bits directly: Char 0 -> Node 0\nfor bit in best_bitstring: \n    if bit == '0':\n        colors.append('lightblue')\n    else:\n        colors.append('salmon')\n\nplt.figure(figsize=(6, 4))\nnx.draw(G, pos, with_labels=True, node_color=colors, edge_color='gray', node_size=700, font_weight='bold')\nplt.title(\"VQE Solution (Robust to Noise)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTop 5 Results (Counts):\n10010: 926\n11010: 791\n10000: 43\n11110: 32\n11000: 29\n\nWinning Configuration: 10010\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](07-matrix-decomposition_files/figure-html/cell-6-output-2.png){width=595 height=423}\n:::\n:::\n\n\n### Understanding the Results: `10010` vs `00101`\n\nYou may notice something interesting. Your classical solver might output `10010`, but your Quantum Sampler outputs `00101`. Are they different?\n\nNo! They are the **exact same solution**, differing only by representation.\n\n1.  **Qiskit Ordering (Little Endian):**\n    Qiskit reads bitstrings from right-to-left. The string `00101` means:\n    * Qubit 0 (Far Right) = 1\n    * Qubit 1 = 0\n    * Qubit 2 = 1\n    * ...\n    Standard Python arrays (like our classical solver) are read left-to-right. This often causes the string to look reversed.\n\n2.  **Symmetry (Bit Flipping):**\n    Max-Cut cares about *differences*, not absolute values.\n    * Partition `00101` (Groups: A, A, B, A, B)\n    * Partition `11010` (Groups: B, B, A, B, A)\n    These are physically identical cuts. Flipping *every* bit results in the exact same cut value.\n\n\n\n## 5. Conclusion: The End of VQE\n\nWe have now completed our VQE journey.\n\n1.  **Implicit State:** We replaced the vector with a parameterized circuit (Ansatz).\n2.  **Implicit Matrix:** We replaced the matrix with a sum of Pauli strings (Hamiltonian).\n3.  **Optimization:** We used a classical loop to find the best parameters.\n\nThis approach allows us to attack problems far larger than our RAM can hold. However, VQE is not perfect. It is an **optimization** algorithm, which means it can get stuck in local minima, and training can be slow.\n\nIn the next series of posts, we will explore **Quantum Krylov Methods**—a completely different approach that uses linear algebra concepts (like power iteration) directly on the quantum computer to find eigenvalues without the messy optimization loop.\n\n",
    "supporting": [
      "07-matrix-decomposition_files"
    ],
    "filters": [],
    "includes": {}
  }
}