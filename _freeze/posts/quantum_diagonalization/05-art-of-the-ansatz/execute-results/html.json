{
  "hash": "a50641e6cb554ef80c8ece5e15f173c9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The Art of the Ansatz: Entanglement and the Hilbert Space Wall\"\ndate: 2025-12-19\ncategories: [Quantum Computing, VQE, Ansatz]\nimage: img/image_0.png\ndescription: \"Why our previous circuit failed, how adding a CNOT gate fixes it, and why even that isn't enough for every matrix.\"\nformat:\n  html:\n    code-fold: show\nexecute:\n  enabled: true\n  freeze: true\n  keep-ipynb: true\njupyter: quantum\ndraft: false\n---\n\nIn our **[previous post](./04-closing-the-loop.qmd)**, we built a hybrid optimization loop that successfully minimized the energy of our quantum circuit. However, when we compared our result to the classical truth, we hit a snag.\n\nThe **Quantum Vector Distance** between our result and the true ground state was significant (around `0.76`).\n\nWhy did it fail? The classical calculation revealed that the true ground state for our Hamiltonian was the **Bell State** $\\frac{1}{\\sqrt{2}}(|01\\rangle - |10\\rangle)$. This is a **maximally entangled** state.\n\nOur previous circuit used only independent rotations (`RY` on qubit 0, `RY` on qubit 1). Mathematically, a tensor product of single qubits can **never** create an entangled state. No matter how much the classical optimizer tuned the angles, the quantum computer was physically incapable of reaching the solution.\n\n## 1. The Fix: Adding Entanglement\n\nThe failure wasn't an issue with the optimizer; it was an issue with the **Ansatz** (the circuit structure). We tried to fit a round peg (an entangled ground state) into a square hole (a product-state circuit).\n\nTo fix this, we need to allow the qubits to talk to each other. We do this by adding a **CNOT (CX)** gate after the rotations. This transforms our circuit from a simple tensor product into a state where the value of qubit 1 depends on qubit 0.\n\n### Implementing the Entangled Ansatz\n\nLet's rebuild the circuit, this time appending a `cx(0, 1)` gate.\n\n::: {#b0096530 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.primitives import StatevectorEstimator\nfrom scipy.optimize import minimize\n\n# Re-defining the Hamiltonian from the previous post\nhamiltonian = SparsePauliOp.from_list([(\"ZZ\", 0.5), (\"XX\", 0.2)])\nestimator = StatevectorEstimator()\n\n# 1. Define Parameters\ntheta_0 = Parameter('θ0')\ntheta_1 = Parameter('θ1')\n\n# 2. Build the Entangled Ansatz\n# RY rotations followed by a CNOT entangler\nqc_entangled = QuantumCircuit(2)\nqc_entangled.ry(theta_0, 0)\nqc_entangled.ry(theta_1, 1)\nqc_entangled.cx(0, 1)  # <--- The magic ingredient\n\nprint(\"Entangled Ansatz:\")\ndisplay(qc_entangled.draw(\"mpl\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEntangled Ansatz:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](05-art-of-the-ansatz_files/figure-html/cell-2-output-2.png){width=232 height=168}\n:::\n:::\n\n\n### Running the Optimization Again\n\nWe use the exact same Hamiltonian ($A$) and the exact same optimizer (COBYLA). The only thing changing is the circuit `qc_entangled`.\n\n::: {#82b58be4 .cell execution_count=2}\n``` {.python .cell-code}\n# Define a new cost function using the entangled circuit\ndef cost_function_entangled(params):\n    # Bind parameters to the NEW circuit\n    pub = (qc_entangled, hamiltonian, params)\n    job = estimator.run([pub])\n    result = job.result()[0]\n    return float(result.data.evs)\n\n# Run Optimization\ninitial_guess = [0.0, 0.0]\nresult_entangled = minimize(cost_function_entangled, initial_guess, method='COBYLA')\n\noptimal_angles_entangled = result_entangled.x\nmin_eigenvalue_entangled = result_entangled.fun\n\n# Check against the true value\n# For H = 0.5*ZZ + 0.2*XX, the eigenvalues are +/- 0.7 and +/- 0.3\n# The minimum is exactly -0.7\ntrue_eigenvalue = -0.7 \n\nprint(f\"Optimization Complete (Entangled)!\")\nprint(f\"Minimum Eigenvalue found: {min_eigenvalue_entangled:.6f}\")\nprint(f\"Classical Truth:          {true_eigenvalue:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimization Complete (Entangled)!\nMinimum Eigenvalue found: -0.700000\nClassical Truth:          -0.700000\n```\n:::\n:::\n\n\n**The Result:** With just one added gate, the optimizer accessed the \"Entangled Subspace\" of the Hilbert space, finding the solution that was previously impossible to reach.\n\n## 2. Verifying the Eigenvector\n\nThe energy looks correct, but we must verify the state itself. Did we actually produce the Bell State? We will use the `StatevectorSampler` to reconstruct the vector magnitudes from the probabilities and compare it to the known truth.\n\n::: {#c7f117be .cell execution_count=3}\n``` {.python .cell-code}\nfrom qiskit.primitives import StatevectorSampler\n\n# 1. Prepare the Circuit for Sampling\nqc_entangled_sampled = qc_entangled.copy()\nqc_entangled_sampled.measure_all()\n\n# 2. Run the Sampler using the OPTIMAL angles\nsampler = StatevectorSampler()\njob_sampler = sampler.run([(qc_entangled_sampled, optimal_angles_entangled)])\nresult_sampler = job_sampler.result()[0]\n\n# 3. Reconstruct the Vector\n# Get counts and convert to probabilities\ncounts = result_sampler.data.meas.get_counts()\ntotal_shots = sum(counts.values())\n\n# We strictly order the states: |00>, |01>, |10>, |11>\nstates = ['00', '01', '10', '11']\n\n# Calculate Probabilities\nprobs = np.array([counts.get(s, 0) / total_shots for s in states])\n\n# Calculate Amplitudes (Sqrt of probability)\nquantum_vector = np.sqrt(probs)\n\n# Define the true vector magnitude (Bell State) for comparison\n# The ground state corresponds to (|01> - |10>) / sqrt(2)\ntrue_vector_abs = np.array([0, 1/np.sqrt(2), 1/np.sqrt(2), 0])\n\nprint(\"Reconstructed Quantum Eigenvector:\")\nprint(quantum_vector)\nprint(\"-\" * 30)\nprint(f\"Quantum Vector Distance: {np.linalg.norm(quantum_vector - true_vector_abs):.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReconstructed Quantum Eigenvector:\n[0.         0.71602745 0.69807212 0.        ]\n------------------------------\nQuantum Vector Distance: 0.012697\n```\n:::\n:::\n\n\nExcellent! The distance is now extremely close to zero. By adding the CNOT gate, our Ansatz was able to capture the entanglement required by the solution.\n\n## 3. Stress Testing the Ansatz\n\nWe have successfully solved the Bell State problem. This raises an important question: **Can this Ansatz solve *any* 4x4 symmetric real matrix?**\n\nOur circuit has successfully captured entanglement, so intuitively, it seems robust. Let's put it to the test with a \"Counterexample Matrix\" designed specifically to break it.\n\n### The Counterexample\nWe will construct a matrix where the ground state is the vector $v = \\frac{1}{\\sqrt{3}}(|00\\rangle + |01\\rangle + |10\\rangle)$.\nNotice that the last component ($|11\\rangle$) is exactly zero.\n\nMathematically, our current Ansatz (Rotation $\\to$ CNOT) forces a specific relationship between the amplitudes: $v_{00} \\cdot v_{11} = v_{01} \\cdot v_{10}$.\nFor our target vector, $1 \\cdot 0 \\neq 1 \\cdot 1$. This vector is mathematically impossible for our current circuit to generate.\n\nLet's see the optimizer fail in real-time.\n\n::: {#26992c42 .cell execution_count=4}\n``` {.python .cell-code}\n# 1. Define the \"Unsolvable\" Hamiltonian\n# Ground State: |v> = [1, 1, 1, 0] / sqrt(3)\n# We create a projector H = -|v><v|\n# The minimum eigenvalue is exactly -1.0\nmatrix_unsolvable = np.array([\n    [-1/3, -1/3, -1/3, 0],\n    [-1/3, -1/3, -1/3, 0],\n    [-1/3, -1/3, -1/3, 0],\n    [ 0,    0,    0,   0]\n])\nhamiltonian_hard = SparsePauliOp.from_operator(matrix_unsolvable)\n\n# 2. Reuse the Same Ansatz (RY-RY-CNOT)\n# We recreate it to ensure fresh parameters\ntheta_0 = Parameter('θ0')\ntheta_1 = Parameter('θ1')\nqc_hard = QuantumCircuit(2)\nqc_hard.ry(theta_0, 0)\nqc_hard.ry(theta_1, 1)\nqc_hard.cx(0, 1) \n\n# 3. Optimize\ndef cost_function_hard(params):\n    pub = (qc_hard, hamiltonian_hard, params)\n    job = estimator.run([pub])\n    return float(job.result()[0].data.evs)\n\nresult_hard = minimize(cost_function_hard, [0.0, 0.0], method='COBYLA')\n\nprint(f\"Target Eigenvalue:       -1.0000\")\nprint(f\"Best Value Found:        {result_hard.fun:.4f}\")\nprint(f\"Error (Gap):             {abs(result_hard.fun - (-1.0)):.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTarget Eigenvalue:       -1.0000\nBest Value Found:        -0.8727\nError (Gap):             0.1273\n```\n:::\n:::\n\n\n**The Failure:** The optimizer gets stuck (likely around `-0.66` or `-0.33`). It cannot reach `-1.0` because the solution lies in the \"blind spot\" of our Ansatz.\n\n## 4. The Conceptual Fix: Degrees of Freedom\n\nWhy did it fail? It comes down to counting parameters.\n\nA normalized real vector in 4 dimensions has **3 degrees of freedom**:\n\n1.  4 amplitudes ($a, b, c, d$).\n\n2.  Minus 1 constraint for normalization ($a^2+b^2+c^2+d^2=1$).\n\n3.  **Total = 3.**\n\nOur current Ansatz only has **2 parameters** ($\\theta_0, \\theta_1$).\nWe are trying to map a 2D surface onto a 3D space. There are vast regions of the Hilbert space we simply cannot reach. To fix this, we need a **third parameter**.\n\n### Introducing the Controlled-RY\nInstead of a fixed `CNOT` (which has 0 parameters), we can conceptually use a parameterized **Controlled-Rotation ($CR_Y$)**.\n\nThis gate rotates the second qubit by an angle $\\theta_2$ *only if* the first qubit is 1. This gives us independent control over the \"top half\" ($|00\\rangle, |01\\rangle$) and \"bottom half\" ($|10\\rangle, |11\\rangle$) of the vector, unlocking the 3rd degree of freedom.\n\n::: {#f6d936ff .cell execution_count=5}\n``` {.python .cell-code}\n# 1. Define 3 Parameters\ntheta_0 = Parameter('θ0')\ntheta_1 = Parameter('θ1')\ntheta_2 = Parameter('θ2') # <--- The new parameter\n\n# 2. Build the \"Perfect\" Ansatz (Conceptually)\nqc_perfect = QuantumCircuit(2)\nqc_perfect.ry(theta_0, 0)\nqc_perfect.ry(theta_1, 1)\nqc_perfect.cry(theta_2, 0, 1) # <--- Parameterized Entanglement\n\n# 3. Optimize with the new circuit\ndef cost_function_perfect(params):\n    pub = (qc_perfect, hamiltonian_hard, params)\n    job = estimator.run([pub])\n    return float(job.result()[0].data.evs)\n\n# We now pass 3 initial guesses\nresult_perfect = minimize(cost_function_perfect, [0.0, 0.0, 0.0], method='COBYLA')\n\nprint(f\"Target Eigenvalue:       -1.0000\")\nprint(f\"Best Value Found (3-Param): {result_perfect.fun:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTarget Eigenvalue:       -1.0000\nBest Value Found (3-Param): -1.0000\n```\n:::\n:::\n\n\n**Success!** With 3 parameters matching the 3 degrees of freedom, the optimizer can now find the exact solution for *any* 4x4 real matrix.\n\n> **Note:** While `CRY` is mathematically perfect here, real hardware (like IBM's) usually doesn't have a native `CRY` gate. We would have to build it out of 2 CNOTs, which increases noise. This is the constant trade-off in Ansatz design: **Expressibility vs. Hardware Cost.**\n\n## 5. The Complications: Why We Can't \"Just Scale Up\"\n\nIn this example, adding one gate solved everything. It seems obvious: just add rotations and CNOTs everywhere, right? Not quite. This brings us to the theoretical wall of Variational Quantum Algorithms.\n\nLet's do the math on how many parameters we actually need as we scale up.\n\n### The Real Symmetric Case (2 qubits, 4 dimensions)\nWe just saw that for a $4 \\times 4$ real symmetric matrix, we need **3** parameters.\n\n* The vector has 4 real values: $a, b, c, d$.\n\n* There is 1 constraint (normalization): $a^2 + b^2 + c^2 + d^2 = 1$.\n\n* **Total parameters:** $4 - 1 = 3$.\n\n### The Real Symmetric Case (N qubits, 2^N dimensions)\nIf we scale this logic up to a system with $N$ qubits, the Hilbert space dimension is $D = 2^N$.\n\n* The vector has $2^N$ real values.\n\n* Normalization removes 1 degree of freedom.\n\n* **Total parameters:** $2^N - 1$.\n\n### The General Quantum Case (Complex Hermitian)\nHowever, quantum mechanics is not real; it is complex.\nFor a general $N$-qubit system, the state vector consists of $2^N$ complex amplitudes ($a + bi$).\n\n* **Raw Numbers:** Each amplitude has 2 real components (real and imaginary parts). So we have $2 \\times 2^N$ total real numbers.\n\n* **Constraint 1 (Normalization):** The sum of probabilities must be 1. (Removes 1 parameter).\n\n* **Constraint 2 (Global Phase):** In quantum mechanics, the states $|\\psi\\rangle$ and $e^{i\\phi}|\\psi\\rangle$ are physically indistinguishable. We can freely choose the global phase. (Removes 1 parameter).\n\n**The Final Count:**\nTo fully define an arbitrary quantum state of $N$ qubits, the number of real parameters required is:\n$$\n\\text{Parameters} = 2(2^N) - 2\n$$\n\n### The Reality Check: N = 50\nLet's look at the numbers for a useful quantum computer:\n\n* **Dimension:** $2^{50} \\approx 10^{15}$ (1 Quadrillion states).\n\n* **Parameters Needed:** $\\approx 2 \\times 10^{15}$.\n\nIf we tried to build a \"universal\" circuit with 1 quadrillion parameters, two things would happen:\n\n1.  **The Quantum Wall:** The circuit would be so deep that noise would destroy the state before we finished preparing it.\n\n2.  **The Classical Wall (Barren Plateaus):** Even with a perfect quantum computer, a classical optimizer cannot handle $10^{15}$ variables. In such a high-dimensional space, the energy landscape becomes essentially flat. The gradient vanishes, and the optimizer gets stuck, having no idea which direction leads \"down\".\n\n## 6. The Solution: The Ansatz\n\nThis is why we cannot simply \"parameterize everything.\" We must be selective. We cannot search the entire Hilbert space. We must choose a specific **subspace** where we suspect the answer lies.\n\nWe define a fixed circuit structure—called an **Ansatz** (German for \"approach\")—that uses a manageable number of parameters (e.g., $N^2$ or even $N$).\n\n$$\n|v(\\vec{\\theta})\\rangle = U_{\\text{Ansatz}}(\\vec{\\theta}) |0\\dots0\\rangle\n$$\n\nThe \"Art\" of VQE is designing an Ansatz that is\n\n\n\n1.  **Expressive enough** to capture the physics of the problem (as we saw with the CNOT).\n\n2.  **Simple enough** to be optimized on real hardware.\n\nIn the next post, we will compare different Ansatz strategies—specifically **Hardware Efficient** circuits vs. **Chemically Inspired** ones (like UCCSD)—to see how we balance accuracy with complexity.\n\n",
    "supporting": [
      "05-art-of-the-ansatz_files"
    ],
    "filters": [],
    "includes": {}
  }
}