{
  "hash": "6507dc07e1ed3cc19a146c539d7f9b26",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Exploring the Ansatz Zoo: Heuristics and the Parameter Gap\"\ndate: 2026-01-18\ncategories: [Quantum Computing, VQE, Ansatz]\nimage: img/ansatz_zoo.png\ndescription: \"We cannot search the entire Hilbert space. We explore the n-local blueprint, why we prefer 2-local circuits, and use RealAmplitudes to find the answer with exponentially fewer parameters.\"\nformat:\n  html:\n    code-fold: show\nexecute:\n  enabled: true\n  freeze: true\n  keep-ipynb: true\njupyter: quantum\ndraft: false\n---\n\n\n\nIn our **[previous post](./05-art-of-the-ansatz.qmd)**, we hit a theoretical wall.\n\nWe calculated that to fully parameterize a unique quantum state for $N$ qubits, we need:\n\n$$ \\text{Params}_{\\text{Full}} = 2(2^N) - 2 $$\n\nFor a practical $N=16$ system, this means searching a **130,000-dimensional** space. No optimizer can handle that. We need to be smarter. We need a \"Heuristic Ansatz\"—a circuit template that explores a relevant slice of the Hilbert space using a manageable number of parameters.\n\n## 1. The Blueprint: `n_local`\n\nThe general strategy for building these templates is the **n-local** architecture. It consists of alternating layers:\n\n1.  **Rotation Layers:** Single-qubit gates (like $R_Y, R_Z$) to explore local states.\n\n2.  **Entanglement Layers:** Multi-qubit gates to mix information.\n\nThe term \"$n$-local\" refers to the size of the entangling blocks. The gates act on at most $n$ qubits at a time. In Qiskit, the `n_local()` function allows us to build any variation of this structure.\n\n### The Road Less Traveled: A 3-Local Example\n\nMost standard ansatzes are **2-local** (using pairs of qubits). But to understand why, let's try to build a **3-local** circuit.\n\nWe could use a 3-qubit gate, like the **Toffoli (CCX)**, as our entangler.\n\n::: {#8eaa9d94 .cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit.circuit.library import n_local\nfrom qiskit import QuantumCircuit\n\n# Building a 3-Local Ansatz\n# Rotations: RY on every qubit\n# Entanglement: CCX (Toffoli) acting on triplets\n# We use reps=3 to give it depth\nansatz_3local = n_local(num_qubits=4,\n                        rotation_blocks=['ry'],\n                        entanglement_blocks='ccx',\n                        entanglement=[[0, 1, 2], [1, 2, 3]], # Explicit triplets\n                        reps=3,\n                        insert_barriers=True)\n\nprint(f\"3-Local Parameters: {ansatz_3local.num_parameters}\")\ndisplay(ansatz_3local.draw('mpl'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3-Local Parameters: 16\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-exploring-the-ansatz-zoo_files/figure-html/cell-2-output-2.png){width=1097 height=291}\n:::\n:::\n\n\n### Why don't we use this?\n\nYou rarely see 3-local (or 4-local) ansatzes in VQE. There are two main reasons:\n\n1.  **Hardware Connectivity:** Real quantum processors (like IBM's heavy-hex lattice) only physically connect qubits in pairs. A 3-qubit gate like `CCX` doesn't exist natively. The compiler has to break it down into **6+ CNOT gates**, making the circuit incredibly deep and noisy.\n\n2.  **Overkill:** We don't *need* 3-body gates to create global entanglement. A layer of 2-body CNOTs can spread information across the entire chip in just a few steps ($O(\\log N)$ depth).\n\n## 2. The Standard: 2-Local\n\nThis is why the **2-local** structure is the gold standard. It matches the native hardware (CNOT/CZ) and is expressive enough to generate complex states.\n\nWhile we can use `n_local` to build them, Qiskit provides optimized helper functions for the two most common patterns: `efficient_su2` and `real_amplitudes`.\n\n### `efficient_su2`: The Generalist\n\nThe `efficient_su2` ansatz is designed to be **universal for local operations**.\n\"SU(2)\" refers to the group of operations on a single qubit. This circuit ensures that every qubit can reach *any* state on its Bloch sphere (using $R_Y$ and $R_Z$) before being entangled.\n\n* **Best for:** Problems with complex eigenvectors (e.g., non-Hermitian matrices, dynamics).\n\n* **Structure:** $R_Y \\to R_Z \\to \\text{CNOT}$.\n\n::: {#3fa0428a .cell execution_count=2}\n``` {.python .cell-code}\nfrom qiskit.circuit.library import efficient_su2\n\n# Standard EfficientSU2 with reps=3\n# This creates 3 full layers of entanglement\nansatz_su2 = efficient_su2(num_qubits=4,\n                           su2_gates=['ry', 'rz'],\n                           entanglement='linear',\n                           reps=3)\n\nprint(f\"EfficientSU2 Parameters: {ansatz_su2.num_parameters}\")\ndisplay(ansatz_su2.draw('mpl'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEfficientSU2 Parameters: 32\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-exploring-the-ansatz-zoo_files/figure-html/cell-3-output-2.png){width=1035 height=291}\n:::\n:::\n\n\n#### Parameter Count (N=16)\nFor a 16-qubit system with depth 3:\n$$ \\text{Params} = 2N(d+1) = 2(16)(4) = 128 $$\nWe have reduced the problem from 130,000 variables to **128**.\n\n### `real_amplitudes`: The Specialist\n\nFor **Matrix Diagonalization** of real symmetric matrices (our main goal), we know the eigenvectors are real.\nWe can strip out the $R_Z$ gates. This reduces the parameter count by half, making the optimization easier.\n\n* **Best for:** Hamiltonian ground states, Machine Learning kernels, Real Symmetric matrices.\n\n* **Structure:** $R_Y \\to \\text{CNOT}$.\n\n::: {#436aa52a .cell execution_count=3}\n``` {.python .cell-code}\nfrom qiskit.circuit.library import real_amplitudes\n\n# Standard RealAmplitudes with reps=3\nansatz_real = real_amplitudes(num_qubits=4,\n                              entanglement='linear',\n                              reps=3)\n\nprint(f\"RealAmplitudes Parameters: {ansatz_real.num_parameters}\")\ndisplay(ansatz_real.draw('mpl'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRealAmplitudes Parameters: 16\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](06-exploring-the-ansatz-zoo_files/figure-html/cell-4-output-2.png){width=788 height=291}\n:::\n:::\n\n\n#### Parameter Count (N=16)\nFor a 16-qubit system with depth 3:\n$$ \\text{Params} = N(d+1) = 16(4) = 64 $$\n**64 variables** is incredibly lightweight. This gives our optimizer the best possible chance of success.\n\n## 3. The Goldilocks Choice: Why `reps=3`?\n\nIn all the examples above, we set `reps=3`. This wasn't an accident. In heuristic ansatz design, the number of repetitions (depth) is the most critical knob we can turn.\n\nIt represents a trade-off between **Expressibility** and **Trainability**.\n\n1.  **Too Shallow (`reps=0` or `1`):**\n    The circuit cannot create enough entanglement. It can only explore \"Product States\" or very simple correlations. It will likely fail to reach the true ground state.\n\n2.  **Too Deep (`reps=50`):**\n    * **Noise:** Every additional layer adds CNOT gates. On current hardware, deep circuits accumulate so much noise that the signal becomes garbage.\n    * **Barren Plateaus:** As we add parameters, the high-dimensional optimization landscape becomes increasingly flat. The gradient vanishes, and the optimizer gets stuck.\n\n3.  **Just Right (`reps=3`):**\n    For many practical problems, 3 layers provide enough entanglement to capture non-trivial correlations, while keeping the parameter count low enough (e.g., 64 vs 1000s) for the classical optimizer to succeed.\n\n## 4. The Road Not Taken: Specialized Ansatzes\n\nThe ansatzes above are \"blind\"—they don't know what problem they are solving. They just explore the space.\n\nIn some fields, we can do better by building the circuit based on the problem's physics. We mention them here for completeness, though we won't use them for general diagonalization.\n\n1.  **UCCSD (Unitary Coupled Cluster):**\n    Used in **Chemistry**. The gates mimic electron excitations. It is incredibly accurate but produces very deep circuits that are hard to run on near-term hardware.\n\n2.  **QAOA (Quantum Approximate Optimization Algorithm):**\n    Used in **Combinatorial Optimization** (e.g., MaxCut). The gates alternate between the \"Cost Hamiltonian\" and a \"Mixer,\" effectively simulating a time-evolution process.\n\n3.  **ZZFeatureMap:**\n    Used in **Machine Learning**. This is used to encode classical data into quantum states (kernels) rather than finding ground states.\n\n**Why don't we use them here?**\nBecause we are solving a **general** linear algebra problem. We don't have the physical intuition of a molecule or a graph to guide us. Therefore, the **Hardware Efficient Ansatz** (`real_amplitudes`) is our best general-purpose tool.\n\n## 5. What's Next?\n\nWe have our Ansatz (`real_amplitudes`) and our strategy (`VQE`). But there is a glaring hole in our pipeline.\n\nIn all our examples so far, we have been \"building\" the matrix $A$ manually in Python (e.g., creating a NumPy array). But if $N=16$, the matrix has **4 billion entries**. We cannot store that in RAM to convert it into a Hamiltonian.\n\nIn the next post, we will learn how to represent the matrix **implicitly**—decomposing a problem into Pauli strings without ever building the full dense matrix.\n\n",
    "supporting": [
      "06-exploring-the-ansatz-zoo_files"
    ],
    "filters": [],
    "includes": {}
  }
}